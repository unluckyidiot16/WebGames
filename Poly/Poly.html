<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì •ë‹¤ê°í˜• ì§„í™” (ì´ˆë“±ìš©)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Nanum+Gothic+Coding:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #E8F5E9;
            font-family: 'Jua', sans-serif;
            touch-action: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            border-radius: 20px;
            background: #FEFDF5;
            max-width: 95%;
            border: 8px solid #8D6E63;
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(232, 245, 233, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
        }
        .ui-panel {
            position: absolute;
            top: 25px;
            pointer-events: none;
            width: 420px;
            max-width: 90%;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        .info-box {
            background: #FFF9C4;
            padding: 10px 20px;
            border-radius: 20px;
            border: 3px solid #FFD54F;
            box-shadow: 0 4px 0 rgba(255, 193, 7, 0.5);
            pointer-events: auto;
            color: #5D4037;
        }
        #evolution-guide {
            position: absolute;
            right: 20px;
            top: 120px;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #AED581;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .guide-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #555;
        }
        .guide-shape {
            width: 20px;
            height: 20px;
            border: 2px solid #555;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
        }
        .danger-line {
            position: absolute;
            /* topì€ JSì—ì„œ ì„¤ì •í•¨ */
            width: 380px;
            max-width: 90%;
            height: 4px;
            border-top: 4px dashed #FF7043;
            pointer-events: none;
            opacity: 0.6;
            z-index: 5;
        }
        .danger-label {
            position: absolute;
            right: 0;
            top: -25px;
            background: #FF7043;
            color: white;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
        }
        .warning-active {
            animation: blink 0.5s infinite;
            border-color: #D32F2F;
            opacity: 1;
        }
        @keyframes blink {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        .btn-start {
            background-color: #4CAF50;
            color: white;
            font-size: 1.5rem;
            padding: 15px 40px;
            border-radius: 50px;
            border: none;
            box-shadow: 0 6px 0 #2E7D32;
            transition: transform 0.1s;
            cursor: pointer;
        }
        .btn-start:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #2E7D32;
        }
        .btn-restart {
            background-color: #FF7043;
            box-shadow: 0 6px 0 #D84315;
        }
        .btn-restart:active {
            box-shadow: 0 2px 0 #D84315;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-panel">
        <div class="info-box">
            <p class="text-sm font-bold opacity-70">ì ìˆ˜</p>
            <p id="score" class="text-2xl font-black">0</p>
        </div>
        <div class="info-box text-right">
            <p class="text-sm font-bold opacity-70">ë‹¤ìŒ ë„í˜•</p>
            <div id="next-shape-display" class="mt-1 flex justify-end items-center h-8"></div>
        </div>
    </div>

    <div id="title-screen" class="overlay">
        <h1 class="text-5xl text-[#2E7D32] mb-4 drop-shadow-sm" style="text-shadow: 2px 2px 0 #fff;">ë„í˜• í•©ì¹˜ê¸°</h1>
        <p class="text-xl text-[#558B2F] mb-10 bg-white px-4 py-2 rounded-full shadow-sm">
            ğŸ”· ê°™ì€ ëª¨ì–‘ë¼ë¦¬ ì¾…! ğŸ”´
        </p>
        <div class="bg-[#FFF9C4] p-6 rounded-3xl border-4 border-[#FFD54F] mb-10 w-64 shadow-md">
            <p class="text-sm font-bold text-[#8D6E63] mb-1">ìµœê³  ê¸°ë¡ ğŸ†</p>
            <p id="best-score" class="text-4xl font-black text-[#F57F17]">0</p>
        </div>
        <button id="start-btn" class="btn-start">ê²Œì„ ì‹œì‘! â–¶</button>
    </div>

    <div id="gameover-screen" class="overlay" style="display: none;">
        <h2 class="text-5xl text-[#D32F2F] mb-4 drop-shadow-md">ì•—, ê½‰ ì°¼ì–´ìš”!</h2>
        <p id="final-score-msg" class="text-2xl text-[#5D4037] mb-8 font-bold">ì ìˆ˜: 0</p>
        <button onclick="location.reload()" class="btn-start btn-restart">ë‹¤ì‹œ í•˜ê¸° ğŸ”„</button>
    </div>

    <div id="evolution-guide" class="hidden md:flex">
        <p class="text-sm text-[#558B2F] font-bold mb-2 text-center">ì§„í™” ìˆœì„œ</p>
    </div>

    <div id="visual-limit-line" class="danger-line">
        <div class="danger-label">ì—¬ê¸° ë„˜ìœ¼ë©´ ì•ˆë¼ìš”!</div>
    </div>
</div>

<script>
    const CONFIG = {
        width: 400,
        height: 640,
        limitY: 200, // ê²Œì„ì˜¤ë²„ ì„ ì„ ë” ì•„ë˜ë¡œ ë‚´ë¦¼ (Yê°’ì´ í´ìˆ˜ë¡ ì•„ë˜)
        spawnY: 50,  // ë„í˜•ì´ ìƒì„±ë˜ì–´ ë–¨ì–´ì§€ëŠ” ìœ„ì¹˜ (ì„ ë³´ë‹¤ í›¨ì”¬ ìœ„)
        shapes: [
            { sides: 3, radius: 25, color: '#FF8A80', name: 'ì‚¼ê°í˜•' },
            { sides: 4, radius: 36, color: '#FFD180', name: 'ì‚¬ê°í˜•' },
            { sides: 5, radius: 47, color: '#FFFF8D', name: 'ì˜¤ê°í˜•' },
            { sides: 6, radius: 58, color: '#CCFF90', name: 'ìœ¡ê°í˜•' },
            { sides: 7, radius: 69, color: '#A7FFEB', name: 'ì¹ ê°í˜•' },
            { sides: 8, radius: 80, color: '#80D8FF', name: 'íŒ”ê°í˜•' },
            { sides: 10, radius: 91, color: '#82B1FF', name: 'ì‹­ê°í˜•' },
            { sides: 12, radius: 102, color: '#B388FF', name: 'ì‹­ì´ê°í˜•' },
            { sides: 0, radius: 115, color: '#FF80AB', name: 'ì™•ìˆ˜ë°•(ì›)' }
        ],
        spawnRange: [0, 1, 2]
    };

    const { Engine, Render, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

    let engine, render, runner;
    let score = 0;
    let bestScore = localStorage.getItem('polygon-suika-kids-best') || 0;
    let isGameOver = false;
    let isGameStarted = false;
    let currentShapeIndex = 0;
    let nextShapeIndex = 0;
    let canDrop = true;
    let previewBody = null;
    let warningTimer = null;

    document.getElementById('best-score').innerText = bestScore;

    function initGame() {
        engine = Engine.create();
        engine.gravity.y = 1.3;

        render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: {
                width: CONFIG.width,
                height: CONFIG.height,
                wireframes: false,
                background: '#FEFDF5'
            }
        });

        // ë²½ ìƒì„±
        const wallColor = '#8D6E63';
        const ground = Bodies.rectangle(CONFIG.width / 2, CONFIG.height + 30, CONFIG.width, 60, { isStatic: true, render: { fillStyle: wallColor } });
        const leftWall = Bodies.rectangle(-30, CONFIG.height / 2, 60, CONFIG.height * 2, { isStatic: true, render: { fillStyle: wallColor } });
        const rightWall = Bodies.rectangle(CONFIG.width + 30, CONFIG.height / 2, 60, CONFIG.height * 2, { isStatic: true, render: { fillStyle: wallColor } });

        Composite.add(engine.world, [ground, leftWall, rightWall]);

        Render.run(render);
        runner = Runner.create();

        // ì‹œê°ì  í•œê³„ì„  ìœ„ì¹˜ ë™ê¸°í™”
        const canvasRect = render.canvas.getBoundingClientRect();
        // ìº”ë²„ìŠ¤ ë‚´ë¶€ì—ì„œì˜ ë¹„ìœ¨ ê³„ì‚° (CSS positionìš©)
        // ì‹¤ì œ ê²Œì„ ë‚´ ì¢Œí‘œê³„ì™€ í™”ë©´ í‘œì‹œ ì¢Œí‘œê³„ ë§¤ì¹­
        // ê°„ë‹¨í•˜ê²Œ top offsetì„ ìº”ë²„ìŠ¤ í¬ê¸° ë¹„ìœ¨ì— ë§ì¶¤
        const lineEl = document.getElementById('visual-limit-line');
        // canvasê°€ ì¤‘ì•™ ì •ë ¬ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, ìº”ë²„ìŠ¤ ìƒë‹¨ ê¸°ì¤€ ì˜¤í”„ì…‹ ê³„ì‚° í•„ìš”
        // í•˜ì§€ë§Œ ì—¬ê¸°ì„  ì‹¬í”Œí•˜ê²Œ %ë¡œ ê·¼ì‚¬ì¹˜ í˜¹ì€ JSë¡œ ì§ì ‘ í”½ì…€ ì§€ì •
        // CSSì—ì„œ position: absoluteëŠ” game-container ê¸°ì¤€ì„.
        // game-container ë†’ì´ê°€ 100vhì´ë¯€ë¡œ ìº”ë²„ìŠ¤ ë†’ì´ì™€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ.
        // ë”°ë¼ì„œ ìº”ë²„ìŠ¤ì˜ ìƒë‹¨ ìœ„ì¹˜ë¥¼ êµ¬í•´ì„œ ë”í•´ì¤˜ì•¼ í•¨.

        // ë” ì‰¬ìš´ ë°©ë²•: ìº”ë²„ìŠ¤ ë Œë”ë§ ë£¨í”„ì—ì„œ ì„ ì„ ê·¸ë¦¬ëŠ” ê²ƒì´ì§€ë§Œ, 
        // HTML ìš”ì†Œë¡œ í‘œì‹œí•˜ë ¤ë©´ ìº”ë²„ìŠ¤ ìœ„ì— ë®ì–´ì”Œì›Œì•¼ í•¨.
        // ì—¬ê¸°ì„œëŠ” game-containerê°€ flex centerì´ë¯€ë¡œ ìº”ë²„ìŠ¤ê°€ ì¤‘ì•™ì— ì˜´.
        // lineì˜ topì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ ë Œë”ë§ ì§í›„ ìœ„ì¹˜ ì¡°ì •
        updateLimitLinePosition();
        window.addEventListener('resize', updateLimitLinePosition);

        setupEvents();
        createGuide();
        setNextShape();
    }

    function updateLimitLinePosition() {
        const lineEl = document.getElementById('visual-limit-line');
        const canvas = document.querySelector('canvas');
        if(canvas) {
            // ìº”ë²„ìŠ¤ ë‚´ì—ì„œì˜ Yì¢Œí‘œ ë¹„ìœ¨
            const ratio = CONFIG.limitY / CONFIG.height;
            // ìº”ë²„ìŠ¤ ì‹¤ì œ í‘œì‹œ ë†’ì´
            const displayHeight = canvas.clientHeight;
            // ìº”ë²„ìŠ¤ ìƒë‹¨ ì—¬ë°± (Flex container center ì •ë ¬ ì‹œ)
            const offsetTop = canvas.offsetTop;

            lineEl.style.top = (offsetTop + displayHeight * ratio) + 'px';
            lineEl.style.width = canvas.clientWidth + 'px';
        }
    }

    function createGuide() {
        const guide = document.getElementById('evolution-guide');
        CONFIG.shapes.forEach(s => {
            const item = document.createElement('div');
            item.className = 'guide-item';
            item.innerHTML = `
                <div class="guide-shape" style="background:${s.color}; border-radius:${s.sides === 0 ? '50%' : '4px'}"></div>
                <span style="font-family:'Jua'">${s.name}</span>
            `;
            guide.appendChild(item);
        });
    }

    function createPolygon(x, y, index, isStatic = false) {
        const conf = CONFIG.shapes[index];
        const options = {
            friction: 0.3,
            restitution: 0.2,
            isStatic: isStatic,
            label: 'polygon',
            render: {
                fillStyle: conf.color,
                strokeStyle: '#5D4037',
                lineWidth: 3
            }
        };

        const body = conf.sides === 0
            ? Bodies.circle(x, y, conf.radius, options)
            : Bodies.polygon(x, y, conf.sides, conf.radius, options);

        body.createdAt = Date.now();
        body.gameData = { index: index };
        return body;
    }

    function setNextShape() {
        currentShapeIndex = nextShapeIndex;
        nextShapeIndex = CONFIG.spawnRange[Math.floor(Math.random() * CONFIG.spawnRange.length)];

        const nextConf = CONFIG.shapes[nextShapeIndex];
        const nextDisplay = document.getElementById('next-shape-display');
        nextDisplay.innerHTML = `<div style="width:28px; height:28px; background:${nextConf.color}; border:2px solid #5D4037; border-radius:${nextConf.sides === 0 ? '50%' : '4px'}"></div>`;
    }

    function setupEvents() {
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const { bodyA, bodyB } = pair;
                if (bodyA.gameData && bodyB.gameData &&
                    bodyA.gameData.index === bodyB.gameData.index) {

                    const currentIndex = bodyA.gameData.index;
                    const maxIndex = CONFIG.shapes.length - 1;

                    if (currentIndex < maxIndex) {
                        const nextIndex = currentIndex + 1;
                        const pos = Vector.div(Vector.add(bodyA.position, bodyB.position), 2);
                        Composite.remove(engine.world, [bodyA, bodyB]);
                        const newBody = createPolygon(pos.x, pos.y, nextIndex);
                        Composite.add(engine.world, newBody);
                        score += (nextIndex + 1) * 10;
                    } else if (currentIndex === maxIndex) {
                        Composite.remove(engine.world, [bodyA, bodyB]);
                        score += 1000;
                    }
                    document.getElementById('score').innerText = score;
                }
            });
        });

        // ê²Œì„ ì˜¤ë²„ ì²´í¬ ë¡œì§ ì—…ë°ì´íŠ¸
        Events.on(engine, 'afterUpdate', () => {
            if (isGameOver || !isGameStarted) return;

            const bodies = Composite.allBodies(engine.world);
            let isViolating = false;
            const now = Date.now();

            for (let body of bodies) {
                if (body.isStatic || body.label !== 'polygon') continue;

                // 1. ë°©ê¸ˆ ìƒì„±ëœ ë„í˜•(ë‚™í•˜ ì¤‘)ì€ ë¬´ì‹œ (2ì´ˆ ìœ ì˜ˆ)
                // ë‹¨, ì´ë¯¸ ì–´ë”˜ê°€ì— ì•ˆì°©í•´ì„œ ì†ë„ê°€ ê±°ì˜ 0ì´ë¼ë©´ 2ì´ˆ ì•ˆ ì§€ë‚¬ì–´ë„ ì²´í¬ ëŒ€ìƒì´ ë¨
                const isSettled = body.speed < 0.2;
                const isOldEnough = (now - body.createdAt > 2000);

                if (isOldEnough || isSettled) {
                    // ë„í˜•ì˜ 'ê°€ì¥ ìœ—ë¶€ë¶„(min.y)'ì´ í•œê³„ì„ (CONFIG.limitY)ë³´ë‹¤ ì‘ìœ¼ë©´(ìœ„ìª½ì´ë©´) ê±¸ì¹œ ê²ƒ
                    // Yì¢Œí‘œëŠ” ì•„ë˜ë¡œ ê°ˆìˆ˜ë¡ ì»¤ì§€ë¯€ë¡œ, ì‘ë‹¤ëŠ” ê²ƒì€ ë” ìœ„ì— ìˆë‹¤ëŠ” ëœ»
                    if (body.bounds.min.y < CONFIG.limitY) {
                        isViolating = true;
                        break;
                    }
                }
            }

            const lineEl = document.getElementById('visual-limit-line');
            if (isViolating) {
                lineEl.classList.add('warning-active');
                if (!warningTimer) {
                    // 2ì´ˆê°„ ê²½ê³  í›„ ê²Œì„ì˜¤ë²„
                    warningTimer = setTimeout(() => {
                        gameOver();
                    }, 2000);
                }
            } else {
                lineEl.classList.remove('warning-active');
                clearTimeout(warningTimer);
                warningTimer = null;
            }
        });

        const gameCanvas = render.canvas;
        const handleMove = (e) => {
            if (!isGameStarted || isGameOver || !canDrop) return;
            const x = getEventX(e);
            const clampedX = Math.max(40, Math.min(CONFIG.width - 40, x));

            if (!previewBody) {
                // ë¯¸ë¦¬ë³´ê¸°ëŠ” spawnY ìœ„ì¹˜ì— í‘œì‹œ
                previewBody = createPolygon(clampedX, CONFIG.spawnY, currentShapeIndex, true);
                Composite.add(engine.world, previewBody);
            } else {
                Body.setPosition(previewBody, { x: clampedX, y: CONFIG.spawnY });
            }
        };

        const handleEnd = (e) => {
            if (!isGameStarted || isGameOver || !canDrop) return;
            const x = getEventX(e);
            const clampedX = Math.max(40, Math.min(CONFIG.width - 40, x));

            if (previewBody) {
                Composite.remove(engine.world, previewBody);
                previewBody = null;
            }

            // ì‹¤ì œ ìƒì„±ë„ spawnY ìœ„ì¹˜ì—ì„œ
            const dropBody = createPolygon(clampedX, CONFIG.spawnY, currentShapeIndex);
            Composite.add(engine.world, dropBody);

            canDrop = false;
            setTimeout(() => {
                if(!isGameOver) {
                    canDrop = true;
                    setNextShape();
                }
            }, 600);
        };

        gameCanvas.addEventListener('mousemove', handleMove);
        gameCanvas.addEventListener('touchstart', handleMove);
        gameCanvas.addEventListener('mousedown', handleEnd);
        gameCanvas.addEventListener('touchend', handleEnd);
    }

    function getEventX(e) {
        const rect = render.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        return (clientX - rect.left) * (CONFIG.width / rect.width);
    }

    function gameOver() {
        if (isGameOver) return;
        isGameOver = true;

        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('polygon-suika-kids-best', bestScore);
        }
        document.getElementById('final-score-msg').innerText = `ë‚´ ì ìˆ˜: ${score}`;
        document.getElementById('gameover-screen').style.display = 'flex';
        Runner.stop(runner);
    }

    document.getElementById('start-btn').onclick = () => {
        document.getElementById('title-screen').style.display = 'none';
        isGameStarted = true;
        updateLimitLinePosition(); // ì‹œì‘ ì‹œ ìœ„ì¹˜ ì¬ê³„ì‚°
        Runner.run(runner, engine);
    };

    initGame();
</script>
</body>
</html>