<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>ë©´ì—­ ì„œë°”ì´ë²„ Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --uiW: 1280; --uiH: 720; }
        body{
            margin:0; height:100vh; overflow:hidden;
            background:#000; font-family: ui-sans-serif, system-ui;
            display:flex; align-items:center; justify-content:center;
        }
        #game-container{ width:100vw; height:100vh; position:relative; }
        canvas{
            position:absolute; inset:0;
            background: radial-gradient(1200px 800px at 50% 45%, #1a2140 0%, #070a14 65%, #000 100%);
            display:block;
            image-rendering: pixelated;
            touch-action: none;
        }
        #ui-wrapper{
            transform-origin: top left;
            width: calc(var(--uiW) * 1px);
            height: calc(var(--uiH) * 1px);
            pointer-events:none;
        }
        .ui-element{ pointer-events: all; }
        /* âœ… ëª¨ë‹¬ ìŠ¤í¬ë¡¤/í„°ì¹˜ ì•ˆì •í™” (ëª¨ë°”ì¼ í¬í•¨) */
        #titleModal, #charModal, #labModal, #levelUpModal, #gameOverModal { pointer-events: all; }
        .scroll-panel { -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y; }
        .pixel-img { image-rendering: pixelated; }

        .modal-backdrop{ background-color: rgba(0,0,0,0.78); }
        .card{
            background:#fff; border:2px solid #cbd5e1;
            border-radius:14px; transition: transform .15s, box-shadow .15s;
        }
        .card:hover{ transform: translateY(-6px); box-shadow: 0 10px 18px rgba(0,0,0,.25); }
        .shake { animation: shake .22s linear; }
        @keyframes shake {
            0%{ transform: translateX(0); }
            25%{ transform: translateX(-4px); }
            50%{ transform: translateX(4px); }
            75%{ transform: translateX(-3px); }
            100%{ transform: translateX(0); }
        }
        .glow { animation: glow 1s ease-in-out infinite alternate; }
        @keyframes glow {
            from { box-shadow: 0 0 5px #4ade80, 0 0 10px #4ade80; }
            to { box-shadow: 0 0 10px #4ade80, 0 0 20px #4ade80; }
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-wrapper" class="absolute top-0 left-0">
        <!-- HUD -->
        <div id="ui" class="relative w-full h-full p-4 text-slate-100 z-10 hidden">
            <div class="flex justify-between items-start">
                <div class="p-3 rounded-xl bg-white/10 backdrop-blur border border-white/10">
                    <div class="flex items-center justify-between gap-4">
                        <div id="level-display" class="font-bold text-xl">ë ˆë²¨: 1</div>
                        <div class="text-sm text-white/70">ì²˜ì¹˜: <span id="kills-text">0</span></div>
                    </div>
                    <div class="w-72 h-7 bg-white/10 rounded-full mt-2 border border-white/15 overflow-hidden">
                        <div id="hp-bar" class="h-full bg-rose-500 rounded-full text-center text-white text-sm" style="width: 100%;"></div>
                    </div>
                    <div class="flex items-center justify-between mt-1">
                        <div id="hp-text" class="text-sm font-semibold">40 / 40</div>
                        <div id="shield-text" class="text-xs text-cyan-300">ğŸ›¡ï¸ 0</div>
                    </div>
                    <div class="mt-2 w-72">
                        <div class="flex justify-between text-[11px] text-white/70 mb-1">
                            <span>ê°ì—¼</span><span id="infection-text">0%</span>
                        </div>
                        <div class="w-full h-2 bg-white/10 rounded-full overflow-hidden border border-white/10">
                            <div id="infection-bar" class="h-full bg-lime-300" style="width:0%"></div>
                        </div>
                    </div>
                    <div class="mt-2 w-72">
                        <div class="flex justify-between text-[11px] text-white/70 mb-1">
                            <span>XP</span><span id="xp-text">0 / 14</span>
                        </div>
                        <div class="w-full h-2 bg-white/10 rounded-full overflow-hidden border border-white/10">
                            <div id="xp-bar" class="h-full bg-violet-400" style="width:0%"></div>
                        </div>
                    </div>
                </div>

                <div class="flex flex-col items-center gap-2">
                    <div id="timer" class="text-4xl font-extrabold bg-white/10 px-5 py-2 rounded-2xl shadow-lg border border-white/10">10:00</div>
                    <div class="text-xs text-white/70">
                        <span class="font-semibold">ì‚´ì•„ë‚¨ê¸°</span> + <span class="font-semibold">ì›€ì§ì´ê¸°</span>
                    </div>
                    <div id="toast" class="hidden px-4 py-2 rounded-xl bg-emerald-500/90 text-white font-bold text-sm"></div>
                </div>

                <div class="flex flex-col items-end gap-2">
                    <div class="flex gap-2">
                        <div class="font-bold text-xl bg-white/10 px-3 py-2 rounded-xl border border-white/10">
                            ATP: <span id="atp-text">0</span>
                        </div>
                        <div class="font-bold text-xl bg-white/10 px-3 py-2 rounded-xl border border-white/10">
                            GOLD: <span id="gold-hud-text">0</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <div id="weapon-ui" class="p-3 rounded-xl bg-white/10 border border-white/10 min-w-52 text-xs"></div>
                        <div id="passive-ui" class="p-3 rounded-xl bg-white/10 border border-white/10 min-w-52 text-xs"></div>
                    </div>
                </div>
            </div>

            <div class="absolute bottom-4 left-4 text-xs text-white/60 bg-white/5 border border-white/10 rounded-xl px-3 py-2">
                PC: WASD/ë°©í–¥í‚¤ â€¢ ëª¨ë°”ì¼: ë“œë˜ê·¸ â€¢ ìŠ¤í˜ì´ìŠ¤: ì¼ì‹œì •ì§€
            </div>

            <div class="absolute bottom-4 right-4 flex gap-2">
                <button id="openLabInGameBtn" class="ui-element bg-white/10 hover:bg-white/15 border border-white/10 text-white px-4 py-2 rounded-xl text-sm">
                    ì—°êµ¬ì†Œ
                </button>
            </div>
        </div>

        <!-- Title -->
        <div id="titleModal" class="absolute inset-0 z-50 flex flex-col items-center justify-center modal-backdrop ui-element">
            <div class="text-center text-white px-6 max-w-3xl">
                <div class="inline-flex items-center gap-3 mb-4">
                    <div class="w-4 h-4 rounded-full bg-pink-400"></div>
                    <div class="w-4 h-4 rounded-full bg-sky-300"></div>
                    <div class="w-4 h-4 rounded-full bg-amber-300"></div>
                </div>
                <h1 class="text-6xl font-black mb-3 tracking-tight">ë©´ì—­ ì„œë°”ì´ë²„</h1>
                <p class="text-lg text-white/80 mb-6">ì„¸í¬ê°€ ë˜ì–´ ë°”ì´ëŸ¬ìŠ¤/ì„¸ê· ì˜ íŒŒë„ë¥¼ ë²„í…¨ë³´ì„¸ìš” ğŸ§«ğŸ¦ </p>

                <div class="flex items-center justify-center gap-3 mb-6">
                    <div class="bg-white/10 border border-white/10 rounded-2xl px-4 py-2 font-bold">
                        GOLD: <span id="gold-title-text">0</span>
                    </div>
                    <div class="bg-white/10 border border-white/10 rounded-2xl px-4 py-2 font-bold">
                        BEST: <span id="best-title-text">-</span>
                    </div>
                </div>

                <div class="flex flex-col gap-3 items-center">
                    <button id="startBtn" class="ui-element bg-emerald-500 hover:bg-emerald-600 text-white font-extrabold py-4 px-10 rounded-2xl text-3xl shadow-lg transition-transform transform hover:scale-[1.02] w-[280px]">
                        ì‹œì‘
                    </button>
                    <button id="openLabBtn" class="ui-element bg-white/10 hover:bg-white/15 border border-white/10 text-white font-bold py-3 px-10 rounded-2xl text-xl w-[280px]">
                        ì—°êµ¬ì†Œ
                    </button>
                </div>

                <div class="mt-6 text-sm text-white/60">
                    Ultimate Edition - ë¬´ê¸° ì§„í™” & ìºë¦­í„° ì„ íƒ
                </div>
            </div>
        </div>

        <!-- Character Select -->
        <div id="charModal" class="hidden absolute inset-0 z-40 flex-col items-center justify-center modal-backdrop ui-element">
            <div class="bg-white/95 p-8 rounded-2xl shadow-2xl text-center max-w-5xl max-h-[90vh] overflow-y-auto scroll-panel">
                <div class="flex items-center justify-between gap-4 mb-4">
                    <div class="text-left">
                        <h2 class="text-3xl font-black text-slate-900">ì„¸í¬ ì„ íƒ</h2>
                        <p class="text-slate-600">ì—­í• ì— ë”°ë¼ ì‹œì‘ ë¬´ê¸°/ìŠ¤íƒ¯ì´ ë‹¬ë¼ìš”.</p>
                    </div>
                    <button id="closeCharBtn" class="ui-element px-4 py-2 rounded-xl bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold">
                        ë‹«ê¸°
                    </button>
                </div>
                <div id="char-options" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
        </div>

        <!-- Research Lab -->
        <div id="labModal" class="hidden absolute inset-0 z-40 flex-col items-center justify-center modal-backdrop ui-element">
            <div class="bg-white/95 p-6 rounded-2xl shadow-2xl max-w-6xl w-[min(1100px,95vw)] max-h-[90vh] overflow-y-auto scroll-panel">
                <div class="flex items-center justify-between gap-4 mb-4">
                    <div class="text-left">
                        <h2 class="text-3xl font-black text-slate-900">ì—°êµ¬ì†Œ</h2>
                        <p class="text-slate-600">GOLDë¡œ ì˜êµ¬ ê°•í™”/í•´ê¸ˆ</p>
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="px-4 py-2 rounded-xl bg-slate-100 border border-slate-200 font-extrabold text-slate-800">
                            GOLD: <span id="gold-lab-text">0</span>
                        </div>
                        <button id="closeLabBtn" class="ui-element px-4 py-2 rounded-xl bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold">
                            ë‹«ê¸°
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                    <div class="text-left">
                        <div class="font-black text-slate-900 text-lg mb-2">ì˜êµ¬ ê°•í™”</div>
                        <div id="upgradeGrid" class="grid grid-cols-1 gap-2"></div>
                    </div>

                    <div class="text-left">
                        <div class="font-black text-slate-900 text-lg mb-2">ë¬´ê¸° í•´ê¸ˆ</div>
                        <div id="unlockGrid" class="grid grid-cols-1 gap-2"></div>
                    </div>

                    <div class="text-left">
                        <div class="font-black text-slate-900 text-lg mb-2">ì§„í™” íŒíŠ¸</div>
                        <div id="evoHints" class="text-xs text-slate-600 space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Level Up -->
        <div id="levelUpModal" class="hidden absolute inset-0 z-30 flex-col items-center justify-center modal-backdrop ui-element">
            <div class="bg-white/95 p-8 rounded-2xl shadow-2xl text-center max-w-5xl">
                <h2 class="text-3xl font-black mb-2 text-slate-800">ë ˆë²¨ ì—…</h2>
                <p class="text-slate-600 mb-6">ë©´ì—­ ë°˜ì‘ì„ ê°•í™”í•˜ì„¸ìš”.</p>
                <div id="card-options" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
        </div>

        <!-- Game Over -->
        <div id="gameOverModal" class="hidden absolute inset-0 z-40 flex-col items-center justify-center modal-backdrop ui-element">
            <div class="bg-white/95 p-10 rounded-2xl shadow-2xl text-center">
                <h2 id="gameOverTitle" class="text-5xl font-black mb-3 text-slate-900">ì¢…ë£Œ</h2>
                <p id="gameOverText" class="text-lg mb-3 text-slate-700">ìŠ¤ì½”ì–´: 0</p>
                <p class="text-slate-700 mb-8">
                    íšë“ GOLD: <span id="runGoldText" class="font-black">0</span>
                </p>
                <div class="flex gap-3 justify-center flex-wrap">
                    <button id="restartBtn" class="ui-element bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-7 rounded-xl text-xl">
                        ë‹¤ì‹œ í•˜ê¸°
                    </button>
                    <button id="openLabFromGameOverBtn" class="ui-element bg-slate-200 hover:bg-slate-300 text-slate-900 font-bold py-3 px-7 rounded-xl text-xl">
                        ì—°êµ¬ì†Œ
                    </button>
                    <button id="backToTitleBtn" class="ui-element bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-7 rounded-xl text-xl">
                        íƒ€ì´í‹€ë¡œ
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    (() => {
        // ===== Canvas / UI =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const uiWrapper = document.getElementById('ui-wrapper');
        const uiContainer = document.getElementById('ui');

        const titleModal = document.getElementById('titleModal');
        const startBtn = document.getElementById('startBtn');
        const openLabBtn = document.getElementById('openLabBtn');
        const openLabInGameBtn = document.getElementById('openLabInGameBtn');
        const charModal = document.getElementById('charModal');
        const closeCharBtn = document.getElementById('closeCharBtn');
        const charOptions = document.getElementById('char-options');

        const labModal = document.getElementById('labModal');
        const closeLabBtn = document.getElementById('closeLabBtn');
        const upgradeGrid = document.getElementById('upgradeGrid');
        const unlockGrid = document.getElementById('unlockGrid');
        const evoHints = document.getElementById('evoHints');

        const levelUpModal = document.getElementById('levelUpModal');
        const cardOptionsContainer = document.getElementById('card-options');

        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverText = document.getElementById('gameOverText');
        const runGoldText = document.getElementById('runGoldText');
        const restartBtn = document.getElementById('restartBtn');
        const openLabFromGameOverBtn = document.getElementById('openLabFromGameOverBtn');
        const backToTitleBtn = document.getElementById('backToTitleBtn');

        const hpBar = document.getElementById('hp-bar');
        const hpText = document.getElementById('hp-text');
        const infectionBar = document.getElementById('infection-bar');
        const infectionText = document.getElementById('infection-text');
        const xpBar = document.getElementById('xp-bar');
        const xpText = document.getElementById('xp-text');
        const levelDisplay = document.getElementById('level-display');
        const timerDisplay = document.getElementById('timer');
        const atpText = document.getElementById('atp-text');
        const weaponUI = document.getElementById('weapon-ui');
        const passiveUI = document.getElementById('passive-ui');
        const killsText = document.getElementById('kills-text');
        const shieldText = document.getElementById('shield-text');

        const goldTitleText = document.getElementById('gold-title-text');
        const bestTitleText = document.getElementById('best-title-text');
        const goldHudText = document.getElementById('gold-hud-text');
        const goldLabText = document.getElementById('gold-lab-text');
        const toast = document.getElementById('toast');

        // ===== Config =====
        const ORIGINAL_UI_WIDTH = 1280;
        const ORIGINAL_UI_HEIGHT = 720;
        const GLOBAL_SCALE = 2.0;

        const IMG_CELL_LIST = Array.from({length:6}, (_,i)=>`png/cell${i}.png`);
        const IMG_VIRUS_LIST = Array.from({length:6}, (_,i)=>`png/virus${i}.png`);

        // ===== Meta (persistent) =====
        const META_KEY = "immune_survivor_ultimate_v1";
        const META_DEFAULT = () => ({
            gold: 0,
            bestScore: 0,
            bestLabel: "",
            upgrades: {
                vitamin: 0,
                vaccine: 0,
                antibiotic: 0,
                hygiene: 0,
                booster: 0,
                training: 0,
                lucky: 0,
            },
            unlockedWeapons: {
                W_MEMBRANE: true,
                W_ANTIBODY: true,
                W_DART: true,
                W_SPIKE: true,
                W_PHAGO: true,
                W_COMPLEMENT: true,
                W_INTERFERON: false,
                W_SHOTGUN: false,
                W_CHAIN: false,
                W_MINE: false,
                W_NEUTRALIZE: false,
                W_LASER: false,
                W_FIELD: false,
                W_BOOMERANG: false,
            }
        });

        function loadMeta(){
            try{
                const raw = localStorage.getItem(META_KEY);
                if(!raw) return META_DEFAULT();
                const m = JSON.parse(raw);
                const d = META_DEFAULT();
                return {
                    ...d,
                    ...m,
                    upgrades: { ...d.upgrades, ...(m.upgrades||{}) },
                    unlockedWeapons: { ...d.unlockedWeapons, ...(m.unlockedWeapons||{}) },
                };
            }catch(e){
                return META_DEFAULT();
            }
        }
        function saveMeta(){
            localStorage.setItem(META_KEY, JSON.stringify(meta));
            syncTitleMetaUI();
        }

        let meta = loadMeta();

        // ===== Research definitions =====
        const UPGRADE_DB = {
            vitamin: { name: "ë¹„íƒ€ë¯¼ ë³µìš©", max: 10, baseCost: 40, costMult: 1.33, short: "ìµœëŒ€ HP +4/ë ˆë²¨", note: "ì˜ì–‘ ë³´ì¶©" },
            vaccine: { name: "ë°±ì‹  íˆ¬ì—¬", max: 10, baseCost: 80, costMult: 1.36, short: "ë°”ì´ëŸ¬ìŠ¤ í”¼í•´ -2%/ë ˆë²¨", note: "ë©´ì—­ ê¸°ì–µ ê°•í™”" },
            antibiotic: { name: "í•­ìƒì œ ë³µìš©", max: 10, baseCost: 60, costMult: 1.35, short: "ì„¸ê·  í”¼í•´ -3%/ë ˆë²¨", note: "2ì°¨ ê°ì—¼ ëŒ€ë¹„" },
            hygiene: { name: "ìœ„ìƒ ìŠµê´€", max: 10, baseCost: 35, costMult: 1.30, short: "ì´ë™ì†ë„ +2%/ë ˆë²¨", note: "ì ‘ì´‰ íšŒí”¼" },
            booster: { name: "ë¶€ìŠ¤í„° ìƒ·", max: 10, baseCost: 70, costMult: 1.34, short: "ì¿¨íƒ€ì„ -2%/ë ˆë²¨", note: "ë°˜ì‘ ì†ë„ ì¦ê°€" },
            training: { name: "ë©´ì—­ í›ˆë ¨", max: 10, baseCost: 50, costMult: 1.32, short: "XP íšë“ +3%/ë ˆë²¨", note: "í•™ìŠµ ì†ë„ ì¦ê°€" },
            lucky: { name: "í–‰ìš´", max: 5, baseCost: 100, costMult: 1.5, short: "ë ˆë²¨ì—… ì„ íƒì§€ +1", note: "ë” ë§ì€ ì„ íƒê¶Œ" },
        };

        const UNLOCK_DB = [
            { id:"W_INTERFERON", name:"ì¸í„°í˜ë¡  íŒŒë™", cost:120, desc:"ì£¼ê¸°ì  ê´‘ì—­ íŒŒë™" },
            { id:"W_SHOTGUN", name:"í•­ì²´ ì‚°íƒ„", cost:140, desc:"5ë°œ ì‚°íƒ„ ë°œì‚¬" },
            { id:"W_CHAIN", name:"ì‚¬ì´í† ì¹´ì¸ ì²´ì¸", cost:170, desc:"ì—°ì‡„ 4íƒ€ê²©" },
            { id:"W_MINE", name:"ë©´ì—­ ì§€ë¢°", cost:160, desc:"ì„¤ì¹˜í˜• í­ë°œ" },
            { id:"W_NEUTRALIZE", name:"ì¤‘í™” í­ë°œ", cost:190, desc:"í­ë°œì„± íˆ¬ì‚¬ì²´" },
            { id:"W_LASER", name:"í•­ì²´ ë ˆì´ì €", cost:220, desc:"ê´€í†µ ì§ì„  ë¹”" },
            { id:"W_FIELD", name:"ì‚¬ì´í† ì¹´ì¸ í•„ë“œ", cost:250, desc:"ì£¼ë³€ ì§€ì† í”¼í•´" },
            { id:"W_BOOMERANG", name:"ë¶€ë©”ë‘ í•­ì²´", cost:200, desc:"ëŒì•„ì˜¤ëŠ” íˆ¬ì‚¬ì²´" },
        ];

        function upgradeCost(key){
            const u = UPGRADE_DB[key];
            const lv = meta.upgrades[key] || 0;
            return Math.floor(u.baseCost * Math.pow(u.costMult, lv));
        }

        function tryBuyUpgrade(key){
            const u = UPGRADE_DB[key];
            const lv = meta.upgrades[key] || 0;
            if(lv >= u.max) return;
            const cost = upgradeCost(key);
            if(meta.gold < cost) return;
            meta.gold -= cost;
            meta.upgrades[key] = lv + 1;
            saveMeta();
            renderLab();
            showToast(`${u.name} Lv.${lv+1} êµ¬ë§¤!`);
        }

        function tryUnlockWeapon(id){
            if(meta.unlockedWeapons[id]) return;
            const item = UNLOCK_DB.find(x => x.id === id);
            if(!item) return;
            if(meta.gold < item.cost) return;
            meta.gold -= item.cost;
            meta.unlockedWeapons[id] = true;
            saveMeta();
            renderLab();
            showToast(`${item.name} í•´ê¸ˆ!`);
        }

        function syncTitleMetaUI(){
            if(goldTitleText) goldTitleText.textContent = `${meta.gold}`;
            if(goldHudText) goldHudText.textContent = `${meta.gold}`;
            if(goldLabText) goldLabText.textContent = `${meta.gold}`;
            if(bestTitleText) bestTitleText.textContent = meta.bestScore > 0 ? `${meta.bestScore}` : "-";
        }

        function renderLab(){
            syncTitleMetaUI();

            upgradeGrid.innerHTML = "";
            for(const key of Object.keys(UPGRADE_DB)){
                const u = UPGRADE_DB[key];
                const lv = meta.upgrades[key] || 0;
                const cost = (lv >= u.max) ? null : upgradeCost(key);
                const can = (cost != null && meta.gold >= cost);

                const el = document.createElement("div");
                el.className = "card p-3 text-left text-sm";
                el.innerHTML = `
                <div class="flex items-start justify-between gap-2">
                    <div>
                        <div class="font-black text-slate-900">${u.name}</div>
                        <div class="text-xs text-slate-600">${u.short}</div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs font-extrabold text-slate-900">Lv.${lv}/${u.max}</div>
                        <div class="text-xs text-slate-500">${cost==null ? "MAX" : cost+"G"}</div>
                    </div>
                </div>
                <button class="ui-element mt-2 w-full ${can ? "bg-emerald-600 hover:bg-emerald-700" : "bg-slate-200"} text-white font-bold py-1 rounded-lg text-xs ${can ? "" : "opacity-70"}">
                    ${cost==null ? "ìµœëŒ€" : (can ? "êµ¬ë§¤" : "ë¶€ì¡±")}
                </button>
            `;
                el.querySelector("button").onclick = () => tryBuyUpgrade(key);
                upgradeGrid.appendChild(el);
            }

            unlockGrid.innerHTML = "";
            for(const item of UNLOCK_DB){
                const unlocked = !!meta.unlockedWeapons[item.id];
                const can = (!unlocked && meta.gold >= item.cost);

                const el = document.createElement("div");
                el.className = "card p-3 text-left text-sm";
                el.innerHTML = `
                <div class="flex items-start justify-between gap-2">
                    <div>
                        <div class="font-black text-slate-900">${item.name}</div>
                        <div class="text-xs text-slate-600">${item.desc}</div>
                    </div>
                    <div class="text-xs text-slate-500">${unlocked ? "âœ“" : item.cost+"G"}</div>
                </div>
                <button class="ui-element mt-2 w-full ${unlocked ? "bg-slate-300" : (can ? "bg-sky-600 hover:bg-sky-700" : "bg-slate-200")} text-white font-bold py-1 rounded-lg text-xs">
                    ${unlocked ? "ì™„ë£Œ" : (can ? "í•´ê¸ˆ" : "ë¶€ì¡±")}
                </button>
            `;
                el.querySelector("button").onclick = () => tryUnlockWeapon(item.id);
                unlockGrid.appendChild(el);
            }

            // Evolution hints
            evoHints.innerHTML = "";
            for(const evo of EVOLUTIONS){
                const w = WEAPON_DB[evo.from];
                const p = PASSIVE_DB[evo.needPassive];
                const t = WEAPON_DB[evo.to];
                if(!w || !p || !t) continue;
                const div = document.createElement("div");
                div.className = "p-2 bg-slate-100 rounded-lg";
                div.innerHTML = `<b>${w.name}</b> Lv.${evo.minLevel} + <b>${p.name}</b> â†’ <span class="text-emerald-600 font-black">${t.name}</span>`;
                evoHints.appendChild(div);
            }
        }

        // ===== Characters =====
        const CHARACTER_DB = {
            macrophage: {
                name: "ëŒ€ì‹ì„¸í¬",
                role: "íƒ±ì»¤",
                desc: "HPâ†‘ ë°©ì–´â†‘ ì†ë„â†“",
                color: "#f472b6",
                mods: (p) => {
                    p.maxHp *= 1.25;
                    p.hp = p.maxHp;
                    p.defense += 2;
                    p.speed *= 0.92;
                    p.infectionGainMult *= 0.85;
                },
                startWeapons: ["W_MEMBRANE", "W_PHAGO"],
                startPassives: ["P_REGEN"]
            },
            tcell: {
                name: "Tì„¸í¬",
                role: "ë”œëŸ¬",
                desc: "ë°ë¯¸ì§€â†‘ HPâ†“",
                color: "#60a5fa",
                mods: (p) => {
                    p.maxHp *= 0.90;
                    p.hp = p.maxHp;
                    p.damageMultiplier += 0.18;
                    p.speed *= 1.05;
                },
                startWeapons: ["W_MEMBRANE", "W_ANTIBODY"],
                startPassives: ["P_AMP"]
            },
            bcell: {
                name: "Bì„¸í¬",
                role: "ì›ê±°ë¦¬",
                desc: "XPâ†‘ ê´€í†µâ†‘ ìˆ˜ì§‘â†‘",
                color: "#a78bfa",
                mods: (p) => {
                    p.xpMultiplier += 0.10;
                    p.projectilePierceBonus += 1;
                    p.pickupRadius *= 1.15;
                },
                startWeapons: ["W_ANTIBODY", "W_COMPLEMENT"],
                startPassives: ["P_MEMORY"]
            },
            nk: {
                name: "NKì„¸í¬",
                role: "ì•”ì‚´ì",
                desc: "ì¹˜ëª…íƒ€â†‘ ì¿¨ê°â†‘",
                color: "#f87171",
                mods: (p) => {
                    p.maxHp *= 0.85;
                    p.hp = p.maxHp;
                    p.critChance += 0.15;
                    p.critDamage += 0.5;
                    p.cooldownReduction *= 0.90;
                },
                startWeapons: ["W_MEMBRANE", "W_ANTIBODY"],
                startPassives: ["P_CRIT"]
            },
            dendritic: {
                name: "ìˆ˜ì§€ìƒì„¸í¬",
                role: "ì„œí¬í„°",
                desc: "XPâ†‘â†‘ ë¬´ê¸°íšë“â†‘",
                color: "#fbbf24",
                mods: (p) => {
                    p.xpMultiplier += 0.25;
                    p.luckyBonus += 1;
                },
                startWeapons: ["W_ANTIBODY"],
                startPassives: ["P_MEMORY", "P_SCAVENGE"]
            },
        };

        const CHAR_SKIN_MAP = {
            macrophage: 0,
            tcell: 1,
            bcell: 2,
            nk: 3,
            dendritic: 4,
        };
        let selectedCharId = "tcell";
        let charSelectReturnState = "title";
        let labReturnState = "title";

        function openCharSelect(){
            setCanvasInputEnabled(false);
            // ì–´ë–¤ í™”ë©´ì—ì„œ ì—´ì–´ë„ ëª¨ë‹¬ì´ ê²¹ì¹˜ì§€ ì•Šê²Œ ì •ë¦¬
            charSelectReturnState = gameState;
            gameOverModal.style.display = "none";
            levelUpModal.style.display = "none";
            labModal.style.display = "none";

            // âœ… íƒ€ì´í‹€ì—ì„œ ìºë¦­í„°ë¥¼ ê³ ë¥´ë©´, íƒ€ì´í‹€ ì˜¤ë²„ë ˆì´ê°€ ë‚¨ì•„ìˆëŠ” í˜„ìƒ ë°©ì§€
            titleModal.style.display = "none";
            titleModal.classList.add("hidden");

            charOptions.innerHTML = "";
            for(const [id, c] of Object.entries(CHARACTER_DB)){
                const card = document.createElement("div");
                card.className = "card ui-element w-56 p-4 cursor-pointer text-left";
                const skin = (CHAR_SKIN_MAP[id] ?? 0);
                card.innerHTML = `
                <div class="flex items-start gap-3">
                    <div class="w-16 h-16 rounded-xl bg-slate-100 border border-slate-200 overflow-hidden flex items-center justify-center">
                        <img class="pixel-img w-full h-full object-contain" src="png/cell${skin}.png" alt="${c.name}" />
                    </div>
                    <div class="flex-1">
                        <div class="flex items-center justify-between mb-1">
                            <div class="text-lg font-black text-slate-900">${c.name}</div>
                            <div class="text-xs font-bold px-2 py-1 rounded-xl" style="background:${c.color}30;color:${c.color}">${c.role}</div>
                        </div>
                        <div class="text-slate-700 text-sm">${c.desc}</div>
                        <div class="mt-2 text-xs text-slate-500">
                            ì‹œì‘: ${c.startWeapons.map(w => WEAPON_DB[w]?.name || w).join(", ")}
                        </div>
                    </div>
                </div>
                <button class="ui-element mt-3 w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 rounded-xl">
                    <span class="inline-flex items-center justify-center gap-2">
                        <img class="pixel-img w-5 h-5" src="png/cell${skin}.png" alt="" />
                        ì„ íƒ
                    </span>
                </button>
            `;
                card.querySelector("button").onclick = () => {
                    selectedCharId = id;
                    charModal.style.display = "none";
                    startGame();
                };
                charOptions.appendChild(card);
            }
            charModal.style.display = "flex";
        }

        // ===== Images =====
        const imageCache = { cell: [], virus: [] };
        function setCanvasInputEnabled(enabled){
            canvas.style.pointerEvents = enabled ? "auto" : "none";
            canvas.style.touchAction = enabled ? "none" : "auto";
        }

        function preloadImages(){
            // preload 6 skins each
            imageCache.cell = IMG_CELL_LIST.map(src => { const img = new Image(); img.src = src; return img; });
            imageCache.virus = IMG_VIRUS_LIST.map(src => { const img = new Image(); img.src = src; return img; });
        }

        // ===== Game State =====
        let gameState = 'title';
        let keys = {};
        let touch = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };

        let player, enemies, projectiles, enemyProjectiles, pickups, effects, mines, summons;
        let camera;
        let lastTime = 0;
        let gameTimeMs = 0;
        let lastSpawnTimes = {};
        let seed = 1;
        let runStats = { kills:0, survivedSec:0, score:0, goldEarned:0 };
        let toastTimer = 0;

        // ===== Content =====
        const WEAPON_DB = {
            // === ê¸°ë³¸ ë¬´ê¸° ===
            W_MEMBRANE: { name:"ì„¸í¬ë§‰ ì¶©ëŒ", desc:"ê·¼ì ‘ ë¶€ì±„ê¼´", baseDmg: 16, cooldown: 700, range: 44*GLOBAL_SCALE, angle: 55, type:'melee' },
            W_ANTIBODY: { name:"í•­ì²´ ë°œì‚¬", desc:"ë‹¨ì¼ íƒ€ê²Ÿ íƒ„í™˜", baseDmg: 11, cooldown: 500, projectileSpeed: 9.5, pierce: 1, projectileSize: 8*GLOBAL_SCALE, type:'ranged' },
            W_DART: { name:"í•­ì²´ ë‹¤íŠ¸", desc:"3ì—°ì‚¬(ì¢ì€ ì‚°íƒ„)", baseDmg: 5, cooldown: 420, pellet: 3, spreadDeg: 12, projectileSpeed: 11.0, pierce: 1, projectileSize: 6*GLOBAL_SCALE, type:'ranged_spread' },
            W_SPIKE: { name:"ë©´ì—­ ìŠ¤íŒŒì´í¬", desc:"ê´€í†µ 2ë°œ", baseDmg: 9, cooldown: 650, projectileSpeed: 12.0, pierce: 2, projectileSize: 7*GLOBAL_SCALE, type:'ranged' },

            W_PHAGO: { name:"ì‹ì„¸í¬ í¬ì‹", desc:"ê°•ë ¥í•œ ì›í˜• ê³µê²©", baseDmg: 28, cooldown: 1400, range: 38*GLOBAL_SCALE, type:'melee_slam' },
            W_COMPLEMENT: { name:"ë³´ì²´ ë§", desc:"ê³µì „ ë³´ì²´", baseDmg: 8, cooldown: 100, count: 1, orbitRadius: 70*GLOBAL_SCALE, orbitSpeed: 2.2, type:'orbital' },

            // === í•´ê¸ˆ ë¬´ê¸° ===
            W_INTERFERON: { name:"ì¸í„°í˜ë¡  íŒŒë™", desc:"ê´‘ì—­ íŒŒë™", baseDmg: 20, cooldown: 3000, maxRadius: 220*GLOBAL_SCALE*0.35, pulseSpeed: 3.2, type:'pulse' },
            W_SHOTGUN: { name:"í•­ì²´ ì‚°íƒ„", desc:"5ë°œ ì‚°íƒ„", baseDmg: 6, cooldown: 800, projectileSpeed: 9.0, pellet: 5, spreadDeg: 28, pierce: 1, projectileSize: 7*GLOBAL_SCALE, type:'ranged_spread' },
            W_CHAIN: { name:"ì‚¬ì´í† ì¹´ì¸ ì²´ì¸", desc:"ì—°ì‡„ 4íƒ€ê²©", baseDmg: 15, cooldown: 1300, bounces: 4, bounceRange: 140*GLOBAL_SCALE*0.55, type:'chain' },
            W_MINE: { name:"ë©´ì—­ ì§€ë¢°", desc:"ì„¤ì¹˜ í­ë°œ", baseDmg: 32, cooldown: 1900, triggerRadius: 52*GLOBAL_SCALE, blastRadius: 95*GLOBAL_SCALE*0.55, type:'mine' },
            W_NEUTRALIZE: { name:"ì¤‘í™” í­ë°œ", desc:"í­ë°œ íˆ¬ì‚¬ì²´", baseDmg: 18, cooldown: 1200, projectileSpeed: 8.2, pierce: 1, projectileSize: 9*GLOBAL_SCALE, blastRadius: 105*GLOBAL_SCALE*0.55, type:'ranged_bomb' },
            W_LASER: { name:"í•­ì²´ ë ˆì´ì €", desc:"ê´€í†µ ë¹”", baseDmg: 25, cooldown: 1800, range: 400*GLOBAL_SCALE*0.5, width: 12, duration: 300, type:'laser' },
            W_FIELD: { name:"ì‚¬ì´í† ì¹´ì¸ í•„ë“œ", desc:"ì£¼ë³€ ì§€ì†í”¼í•´", baseDmg: 3, cooldown: 200, radius: 80*GLOBAL_SCALE, type:'field' },
            W_BOOMERANG: { name:"ë¶€ë©”ë‘ í•­ì²´", desc:"ëŒì•„ì˜¤ëŠ” íˆ¬ì‚¬ì²´", baseDmg: 14, cooldown: 1100, projectileSpeed: 7.0, projectileSize: 12*GLOBAL_SCALE, maxDist: 200*GLOBAL_SCALE, type:'boomerang' },

            // === ì§„í™” ë¬´ê¸° (hidden) ===
            W_VACCINE_BOLT: { hidden:true, name:"ë°±ì‹  ë³¼íŠ¸", desc:"ê°•í™” ì—°ì‚¬", baseDmg: 18, cooldown: 280, projectileSpeed: 12.5, projectileSize: 9*GLOBAL_SCALE, pierce: 3, type:'ranged' },
            W_INTERFERON_STORM: { hidden:true, name:"ì¸í„°í˜ë¡  í­í’", desc:"ëŒ€í˜• ì—°ì†íŒŒë™", baseDmg: 22, cooldown: 1600, maxRadius: 300*GLOBAL_SCALE*0.35, pulseSpeed: 4.4, type:'pulse' },
            W_COMPLEMENT_SWARM: { hidden:true, name:"ë³´ì²´ ìŠ¤ì›œ", desc:"ë‹¤ìˆ˜ ê³ ì† ê³µì „", baseDmg: 12, cooldown: 100, count: 4, orbitRadius: 85*GLOBAL_SCALE, orbitSpeed: 3.0, type:'orbital' },
            W_MEMBRANE_BLADE: { hidden:true, name:"ì„¸í¬ë§‰ ë¸”ë ˆì´ë“œ", desc:"ê´‘ì—­ ì—°ì†ë² ê¸°", baseDmg: 24, cooldown: 450, range: 65*GLOBAL_SCALE, angle: 100, type:'melee' },
            W_SHOTGUN_STORM: { hidden:true, name:"ì‚°íƒ„ í­í’", desc:"8ë°œ ì‚°íƒ„", baseDmg: 8, cooldown: 600, projectileSpeed: 10, pellet: 8, spreadDeg: 50, pierce: 2, projectileSize: 8*GLOBAL_SCALE, type:'ranged_spread' },
            W_CHAIN_LIGHTNING: { hidden:true, name:"ì—°ì‡„ ë²ˆê°œ", desc:"8ì—°ì‡„ ê°•í™”", baseDmg: 20, cooldown: 1000, bounces: 8, bounceRange: 180*GLOBAL_SCALE*0.55, type:'chain' },
            W_SUPER_BOMB: { hidden:true, name:"ìŠˆí¼ í­íƒ„", desc:"ê±°ëŒ€ í­ë°œ", baseDmg: 35, cooldown: 1400, projectileSpeed: 7.0, pierce: 1, projectileSize: 14*GLOBAL_SCALE, blastRadius: 160*GLOBAL_SCALE*0.55, type:'ranged_bomb' },
            W_CLUSTER_MINE: { hidden:true, name:"í´ëŸ¬ìŠ¤í„° ì§€ë¢°", desc:"ë¶„ì—´ í­ë°œ", baseDmg: 25, cooldown: 2200, triggerRadius: 60*GLOBAL_SCALE, blastRadius: 120*GLOBAL_SCALE*0.55, cluster: 4, type:'mine' },
            W_MEGA_LASER: { hidden:true, name:"ë©”ê°€ ë ˆì´ì €", desc:"ê´€í†µ ëŒ€í˜•ë¹”", baseDmg: 45, cooldown: 2000, range: 500*GLOBAL_SCALE*0.5, width: 24, duration: 400, type:'laser' },
            W_PLASMA_FIELD: { hidden:true, name:"í”Œë¼ì¦ˆë§ˆ í•„ë“œ", desc:"ê°•í™” ì§€ì†í”¼í•´", baseDmg: 6, cooldown: 150, radius: 120*GLOBAL_SCALE, type:'field' },
        };

        // ===== Weapon Evolution =====
        const EVOLUTIONS = [
            { from:'W_ANTIBODY', needPassive:'P_PIERCE', minLevel:5, to:'W_VACCINE_BOLT', text:'í•­ì²´ ë°œì‚¬ â†’ ë°±ì‹  ë³¼íŠ¸' },
            { from:'W_INTERFERON', needPassive:'P_CYTOKINE', minLevel:4, to:'W_INTERFERON_STORM', text:'ì¸í„°í˜ë¡  â†’ í­í’' },
            { from:'W_COMPLEMENT', needPassive:'P_AMP', minLevel:4, to:'W_COMPLEMENT_SWARM', text:'ë³´ì²´ ë§ â†’ ìŠ¤ì›œ' },
            { from:'W_MEMBRANE', needPassive:'P_RANGE', minLevel:4, to:'W_MEMBRANE_BLADE', text:'ì„¸í¬ë§‰ â†’ ë¸”ë ˆì´ë“œ' },
            { from:'W_SHOTGUN', needPassive:'P_PIERCE', minLevel:4, to:'W_SHOTGUN_STORM', text:'ì‚°íƒ„ â†’ í­í’' },
            { from:'W_CHAIN', needPassive:'P_AMP', minLevel:4, to:'W_CHAIN_LIGHTNING', text:'ì²´ì¸ â†’ ë²ˆê°œ' },
            { from:'W_NEUTRALIZE', needPassive:'P_RANGE', minLevel:4, to:'W_SUPER_BOMB', text:'ì¤‘í™” â†’ ìŠˆí¼í­íƒ„' },
            { from:'W_MINE', needPassive:'P_THORNS', minLevel:4, to:'W_CLUSTER_MINE', text:'ì§€ë¢° â†’ í´ëŸ¬ìŠ¤í„°' },
            { from:'W_LASER', needPassive:'P_AMP', minLevel:4, to:'W_MEGA_LASER', text:'ë ˆì´ì € â†’ ë©”ê°€' },
            { from:'W_FIELD', needPassive:'P_RANGE', minLevel:4, to:'W_PLASMA_FIELD', text:'í•„ë“œ â†’ í”Œë¼ì¦ˆë§ˆ' },
        ];

        function tryEvolveWeapons(){
            if(!player || !player.weapons) return false;
            let evolved = false;

            for(const evo of EVOLUTIONS){
                const w = player.weapons[evo.from];
                if(!w) continue;
                if(player.weapons[evo.to]) continue;
                if(!player.passives || !player.passives[evo.needPassive]) continue;
                if((w.level || 1) < evo.minLevel) continue;

                delete player.weapons[evo.from];
                addWeapon(evo.to, true, true);
                player.weapons[evo.to].level = 1;
                player.weapons[evo.to].timer = 0;

                showToast(`âš¡ ë¬´ê¸° ì§„í™”! ${evo.text}`);
                evolved = true;
            }
            return evolved;
        }

        const PASSIVE_DB = {
            P_MEMBRANE: { name:"ë§‰ ê°•í™”", desc:"ë°©ì–´ë ¥ +2", effect: p => { p.defense += 2; } },
            P_CHEMO: { name:"ì£¼í™”ì„±", desc:"ì´ë™ì†ë„ +15%", effect: p => { p.speed *= 1.15; } },
            P_MITO: { name:"ë¯¸í†  ë¶€ìŠ¤íŠ¸", desc:"ìµœëŒ€ HP +15%", effect: p => { p.maxHp *= 1.15; p.hp = Math.min(p.hp, p.maxHp); } },
            P_AMP: { name:"í•­ì²´ ì¦í­", desc:"í”¼í•´ +12%", effect: p => { p.damageMultiplier += 0.12; } },
            P_MEMORY: { name:"ë©´ì—­ ê¸°ì–µ", desc:"XP +10%", effect: p => { p.xpMultiplier += 0.10; } },
            P_CYTOKINE: { name:"ì‚¬ì´í† ì¹´ì¸", desc:"ì¿¨íƒ€ì„ -6%", effect: p => { p.cooldownReduction *= 0.94; } },
            P_RANGE: { name:"ë²”ìœ„ í™•ì¥", desc:"ë²”ìœ„ +20%", effect: p => {
                    Object.values(p.weapons).forEach(w => {
                        if (w.type === 'melee' || w.type === 'melee_slam') { w.range *= 1.2; if(w.angle) w.angle *= 1.15; }
                        if (w.type === 'pulse') w.maxRadius *= 1.2;
                        if (w.type === 'orbital') w.orbitRadius *= 1.12;
                        if (w.type === 'mine' || w.type === 'ranged_bomb') { if(w.blastRadius) w.blastRadius *= 1.15; if(w.triggerRadius) w.triggerRadius *= 1.15; }
                        if (w.type === 'field') w.radius *= 1.2;
                        if (w.type === 'laser') { w.range *= 1.15; w.width *= 1.2; }
                    });
                }},
            P_REGEN: { name:"ìê°€ íšŒë³µ", desc:"ì´ˆë‹¹ HP +0.7", effect: p => { p.regenPerSec += 0.7; } },
            P_SCAVENGE: { name:"í¡ìˆ˜ ë²”ìœ„", desc:"íšë“ ë²”ìœ„ +25%", effect: p => { p.pickupRadius *= 1.25; } },
            P_PIERCE: { name:"ê´€í†µ í•­ì²´", desc:"íˆ¬ì‚¬ì²´ ê´€í†µ +1", effect: p => { p.projectilePierceBonus += 1; } },
            P_THORNS: { name:"ì ‘ì´‰ ë°˜ê²©", desc:"ê·¼ì ‘ ì ì—ê²Œ ë°˜ê²©", effect: p => { p.thorns += 5; } },
            P_KILLHEAL: { name:"í¬ì‹ ë³´ë„ˆìŠ¤", desc:"ì²˜ì¹˜ ì‹œ HP +0.2", effect: p => { p.healOnKill += 0.2; } },
            P_CLEAN: { name:"í•´ë… íš¨ì†Œ", desc:"ê°ì—¼ ê°ì†Œ +25%", effect: p => { p.infectionDecayMult *= 1.25; } },
            P_SHIELD: { name:"ë³´í˜¸ë§‰ ì¬ìƒ", desc:"ë³´í˜¸ë§‰ ì£¼ê¸° -20%", effect: p => { p.shieldInterval *= 0.8; } },
            P_CRIT: { name:"ì¹˜ëª…íƒ€", desc:"ì¹˜ëª…íƒ€ í™•ë¥  +8%", effect: p => { p.critChance += 0.08; } },
            P_CRITDMG: { name:"ì¹˜ëª…íƒ€ ê°•í™”", desc:"ì¹˜ëª…íƒ€ ë°ë¯¸ì§€ +30%", effect: p => { p.critDamage += 0.30; } },
            P_LIFESTEAL: { name:"í¡í˜ˆ", desc:"í”¼í•´ì˜ 3% íšŒë³µ", effect: p => { p.lifesteal += 0.03; } },
            P_GROWTH: { name:"ì„±ì¥", desc:"ë ˆë²¨ë‹¹ ë°ë¯¸ì§€ +2%", effect: p => { p.growthDmgPerLevel += 0.02; } },
            P_MAGNET: { name:"ê°•ë ¥ ìì„", desc:"íšë“ ë²”ìœ„ +40%", effect: p => { p.pickupRadius *= 1.40; } },
        };

        const ENEMY_CATALOG = {
            virus:        { name:'ë°”ì´ëŸ¬ìŠ¤',         hp: 18, dmg: 4, spd: 2.7, size: 18*GLOBAL_SCALE, xp: 1, imgKey: 'virus' },
            fastVirus:    { name:'ëŒì—°ë³€ì´',         hp: 16, dmg: 4, spd: 3.8, size: 16*GLOBAL_SCALE, xp: 2, imgKey: 'virus' },
            tankVirus:    { name:'ìº¡ì‹œë“œ ê°•í™”ì²´',    hp: 50, dmg: 6, spd: 2.0, size: 24*GLOBAL_SCALE, xp: 3, imgKey: 'virus' },
            clusterVirus: { name:'êµ°ì§‘ ë°”ì´ëŸ¬ìŠ¤',    hp: 28, dmg: 5, spd: 2.5, size: 20*GLOBAL_SCALE, xp: 3, imgKey: 'virus' },
            spitterVirus: { name:'ìŠ¤í”¼í„°',           hp: 24, dmg: 3, spd: 2.2, size: 19*GLOBAL_SCALE, xp: 3, imgKey: 'virus' },
            chargerVirus: { name:'ì°¨ì €',             hp: 28, dmg: 8, spd: 2.4, size: 19*GLOBAL_SCALE, xp: 4, imgKey: 'virus' },
            bacteria:     { name:'ì„¸ê· ',             hp: 38, dmg: 6, spd: 2.3, size: 21*GLOBAL_SCALE, xp: 4, imgKey: 'virus' },
            superVirus:   { name:'ìŠˆí¼ë°”ì´ëŸ¬ìŠ¤',     hp: 500, dmg: 12, spd: 2.0, size: 32*GLOBAL_SCALE, xp: 30, imgKey: 'virus' },
        };

        const SPAWNER_CLIPS = [
            { start: 0,   end: 60,  enemies: [{ type:"virus", every: 1.3, count:[6,9] }] },
            { start: 60,  end: 120, enemies: [{ type:"virus", every: 1.4, count:[7,10] }, { type:"fastVirus", every: 3.5, count:[2,3] }] },
            { start: 120, end: 210, enemies: [{ type:"fastVirus", every: 3.0, count:[2,4] }, { type:"clusterVirus", every: 3.5, count:[3,5] }] },
            { start: 210, end: 300, enemies: [{ type:"clusterVirus", every: 2.8, count:[4,6] }, { type:"tankVirus", every: 5.0, count:[1,2] }, { type:"spitterVirus", every: 5.0, count:[1,2] }] },
            { start: 300, end: 420, enemies: [{ type:"virus", every: 1.2, count:[10,15] }, { type:"tankVirus", every: 4.2, count:[1,2] }, { type:"spitterVirus", every: 4.0, count:[2,3] }, { type:"chargerVirus", every: 4.5, count:[1,2] }] },
            { start: 420, end: 540, enemies: [{ type:"clusterVirus", every: 2.0, count:[5,8] }, { type:"tankVirus", every: 3.5, count:[2,3] }, { type:"spitterVirus", every: 3.5, count:[2,4] }, { type:"chargerVirus", every: 3.8, count:[2,3] }] },
            { start: 540, end: 9999, enemies: [{ type:"virus", every: 0.9, count:[12,18] }, { type:"fastVirus", every: 2.0, count:[4,7] }, { type:"tankVirus", every: 3.0, count:[2,4] }, { type:"spitterVirus", every: 2.8, count:[3,5] }, { type:"chargerVirus", every: 3.0, count:[3,5] }] },
        ];

        // ===== Utils =====
        function rand(){
            seed = (seed * 1664525 + 1013904223) >>> 0;
            return seed / 4294967296;
        }
        function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

        function showToast(msg, ms = 1800){
            if(!toast) return;
            toast.textContent = msg;
            toast.classList.remove('hidden');
            toastTimer = ms;
        }

        function resizeGame(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const scaleX = canvas.width / ORIGINAL_UI_WIDTH;
            const scaleY = canvas.height / ORIGINAL_UI_HEIGHT;
            const uiScale = Math.min(scaleX, scaleY);

            uiWrapper.style.transform = `scale(${uiScale})`;
            const uiLeft = (canvas.width - ORIGINAL_UI_WIDTH * uiScale) / 2;
            const uiTop  = (canvas.height - ORIGINAL_UI_HEIGHT * uiScale) / 2;
            uiWrapper.style.left = `${uiLeft}px`;
            uiWrapper.style.top  = `${uiTop}px`;
        }

        // ===== Core init =====
        function initGame(){
            gameTimeMs = 600 * 1000;
            lastSpawnTimes = {};
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            pickups = [];
            effects = [];
            mines = [];
            summons = [];
            camera = { x:0, y:0 };

            runStats = { kills:0, survivedSec:0, score:0, goldEarned:0 };

            player = {
                x:0, y:0,
                size: 26 * GLOBAL_SCALE,
                speed: 3.0,
                hp: 40, maxHp: 40,
                defense: 0,
                level: 1,
                xp: 0,
                xpToNextLevel: 14,
                pickupRadius: 54 * GLOBAL_SCALE,
                weapons: {},
                passives: {},
                invincible: false,
                invincibleTimer: 0,

                xpMultiplier: 1.0,
                cooldownReduction: 1.0,
                damageMultiplier: 1.0,
                projectilePierceBonus: 0,
                regenPerSec: 0,
                thorns: 0,
                healOnKill: 0,

                infectionGainMult: 1.0,
                infectionDecayMult: 1.0,
                infection: 0,

                virusDamageTakenMult: 1.0,
                bacteriaDamageTakenMult: 1.0,

                atp: 0,
                kills: 0,

                shields: 0,
                shieldInterval: 15000,
                shieldTimer: 15000,

                stationaryMs: 0,

                critChance: 0.05,
                critDamage: 1.5,
                lifesteal: 0,
                growthDmgPerLevel: 0,
                luckyBonus: 0,
            };

            applyMetaUpgrades(player);

            const char = CHARACTER_DB[selectedCharId] || CHARACTER_DB.tcell;
            char.mods(player);

            for(const wid of char.startWeapons) addWeapon(wid, true, true);
            for(const pid of char.startPassives) addPassive(pid);

            player.invincible = true;
            player.invincibleTimer = 1200;

            updateUI();
        }

        function applyMetaUpgrades(p){
            const u = meta.upgrades;
            if(u.vitamin > 0){ p.maxHp += 4 * u.vitamin; p.hp = p.maxHp; }
            if(u.hygiene > 0){ p.speed *= (1 + 0.02 * u.hygiene); }
            if(u.training > 0){ p.xpMultiplier *= (1 + 0.03 * u.training); }
            if(u.booster > 0){ p.cooldownReduction *= clamp(1 - 0.02 * u.booster, 0.78, 1.0); }
            if(u.vaccine > 0){ p.virusDamageTakenMult = clamp(1 - 0.02 * u.vaccine, 0.75, 1.0); if(u.vaccine >= 5) p.shields += 1; }
            if(u.antibiotic > 0){ p.bacteriaDamageTakenMult = clamp(1 - 0.03 * u.antibiotic, 0.70, 1.0); }
            if(u.lucky > 0){ p.luckyBonus += u.lucky; }
        }

        function startGame(){
            initGame();
            gameState = 'playing';
            setCanvasInputEnabled(true);
            titleModal.style.display = 'none';
            titleModal.classList.add('hidden');
            gameOverModal.style.display = 'none';
            labModal.style.display = 'none';
            charModal.style.display = 'none';
            uiContainer.classList.remove('hidden');
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function backToTitle(){
            gameState = 'title';
            setCanvasInputEnabled(false);
            uiContainer.classList.add('hidden');
            gameOverModal.style.display = 'none';
            levelUpModal.style.display = 'none';
            labModal.style.display = 'none';
            charModal.style.display = 'none';
            titleModal.classList.remove('hidden');
            titleModal.style.display = 'flex';
            lastTime = 0;
            draw();
        }

        // ===== Input =====
        function getMoveVector(){
            let dx = 0, dy = 0;
            if(keys['ArrowUp'] || keys['w'] || keys['W']) dy -= 1;
            if(keys['ArrowDown'] || keys['s'] || keys['S']) dy += 1;
            if(keys['ArrowLeft'] || keys['a'] || keys['A']) dx -= 1;
            if(keys['ArrowRight'] || keys['d'] || keys['D']) dx += 1;
            if(touch.active){ dx += touch.dx; dy += touch.dy; }
            const mag = Math.hypot(dx, dy);
            if(mag <= 0.0001) return { dx:0, dy:0 };
            return { dx: dx/mag, dy: dy/mag };
        }

        // ===== Update loop =====
        function update(dt){
            // toast
            if(toastTimer > 0){
                toastTimer -= dt;
                if(toastTimer <= 0){
                    toastTimer = 0;
                    if(toast) toast.classList.add('hidden');
                }
            }

            const mv = getMoveVector();
            const moved = !!(mv.dx || mv.dy);
            if(moved){
                player.x += mv.dx * player.speed * (dt/16.67);
                player.y += mv.dy * player.speed * (dt/16.67);
                player.infection = Math.max(0, player.infection - 0.02 * dt);
                player.stationaryMs = 0;
            } else {
                player.stationaryMs = (player.stationaryMs || 0) + dt;
                if(player.stationaryMs > 1500){
                    player.infection = clamp(player.infection + 0.012 * dt, 0, 120);
                }
            }

            camera.x = player.x - canvas.width/2;
            camera.y = player.y - canvas.height/2;

            if(player.invincibleTimer > 0){
                player.invincibleTimer -= dt;
                if(player.invincibleTimer <= 0) player.invincible = false;
            }

            const dtSec = dt/1000;

            // regen
            if(player.regenPerSec > 0){
                player.hp = Math.min(player.maxHp, player.hp + player.regenPerSec * dtSec);
            }

            // infection decay + dot
            player.infection = Math.max(0, player.infection - (8.0 * player.infectionDecayMult) * dtSec);
            if(player.infection > 1){
                const drain = (player.infection / 100) * 1.2;
                player.hp -= drain * dtSec;
            }

            // shields
            player.shieldTimer -= dt;
            if(player.shieldTimer <= 0){
                player.shieldTimer += player.shieldInterval;
                player.shields = Math.min(3, player.shields + 1);
            }

            if(player.hp <= 0){
                player.hp = 0;
                loseGame();
                return;
            }

            spawnEnemies();

            // weapons
            Object.values(player.weapons).forEach(w => {
                w.timer -= dt;
                if(w.timer <= 0){
                    fireWeapon(w);
                    w.timer = w.cooldown * player.cooldownReduction;
                }
                if(w.type === 'orbital'){
                    w.orbitals.forEach(o => o.angle += w.orbitSpeed*(dt/1000));
                }
            });

            // mines
            for(let i=mines.length-1; i>=0; i--){
                const m = mines[i];
                m.timer += dt;
                if(!m.armed && m.timer > 350) m.armed = true;
                if(m.armed){
                    for(const e of enemies){
                        if(Math.hypot(e.x - m.x, e.y - m.y) < m.triggerRadius){
                            explodeMine(m);
                            mines.splice(i, 1);
                            break;
                        }
                    }
                }
                if(m.timer > 7000) mines.splice(i, 1);
            }

            // enemies
            enemies.forEach(e => updateEnemy(e, dt));

            // projectiles
            for(let i=projectiles.length-1; i>=0; i--){
                const p = projectiles[i];
                updateProjectile(p, dt);
                if(p.lived > 2500 || p.dead) projectiles.splice(i, 1);
            }

            // enemy projectiles
            for(let i=enemyProjectiles.length-1; i>=0; i--){
                const p = enemyProjectiles[i];
                p.x += Math.cos(p.angle) * p.speed * (dt/16.67);
                p.y += Math.sin(p.angle) * p.speed * (dt/16.67);
                p.lived += dt;
                if(p.lived > p.maxLife) enemyProjectiles.splice(i, 1);
            }

            // pickups
            pickups.forEach(p => updatePickup(p));

            // effects
            effects = effects.filter(e => {
                e.duration -= dt;
                if(e.type === 'pulse') e.currentRadius += e.pulseSpeed * (dt/16.67);
                return e.duration > 0;
            });

            checkCollisions();

            // timer
            gameTimeMs -= dt;
            if(gameTimeMs < 0) gameTimeMs = 0;

            // super virus
            const elapsed = (600000 - gameTimeMs) / 1000;
            if(elapsed > 545 && !lastSpawnTimes.__super){
                lastSpawnTimes.__super = elapsed;
                spawnSuperVirus();
            }

            if(gameTimeMs <= 0){
                winGame("ë©´ì—­ì´ ë²„í…¼ìŠµë‹ˆë‹¤!");
            }
        }

        // ===== Combat helpers =====
        function findClosestEnemy(x, y){
            let closest = null;
            let best = Infinity;
            for(const e of enemies){
                const d = Math.hypot(x - e.x, y - e.y);
                if(d < best){ best = d; closest = e; }
            }
            return closest;
        }

        function calcDamage(baseDmg){
            let dmg = baseDmg * player.damageMultiplier * (1 + player.growthDmgPerLevel * (player.level - 1));
            const isCrit = rand() < player.critChance;
            if(isCrit) dmg *= player.critDamage;
            return { dmg, isCrit };
        }

        function fireWeapon(w){
            const closest = findClosestEnemy(player.x, player.y);
            const angle = closest ? Math.atan2(closest.y - player.y, closest.x - player.x) : 0;

            const { dmg } = calcDamage(w.baseDmg);

            if(w.type === 'melee'){
                if(!closest) return;
                for(const enemy of enemies){
                    const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                    if(dist < w.range + 10){
                        let aDiff = Math.abs(angle - Math.atan2(enemy.y - player.y, enemy.x - player.x));
                        if(aDiff > Math.PI) aDiff = 2*Math.PI - aDiff;
                        if(aDiff < (w.angle*Math.PI/180)/2){
                            const { dmg:finalDmg, isCrit } = calcDamage(w.baseDmg);
                            enemyTakeDamage(enemy, finalDmg, isCrit);
                        }
                    }
                }
                effects.push({ type:'slash_arc', x:player.x, y:player.y, angle, range:w.range, angleWidth:w.angle*Math.PI/180, duration:140, maxDuration:140 });
                return;
            }

            if(w.type === 'melee_slam'){
                if(!closest) return;
                const slamX = closest.x;
                const slamY = closest.y;
                for(const enemy of enemies){
                    if(Math.hypot(enemy.x - slamX, enemy.y - slamY) < w.range){
                        const { dmg:finalDmg, isCrit } = calcDamage(w.baseDmg);
                        enemyTakeDamage(enemy, finalDmg, isCrit);
                    }
                }
                effects.push({ type:'slam_circle', x:slamX, y:slamY, radius:w.range, duration:220, maxDuration:220 });
                return;
            }

            if(w.type === 'ranged'){
                if(!closest) return;
                projectiles.push(makeProjectile(player.x, player.y, angle, w.projectileSpeed, dmg, w.pierce + player.projectilePierceBonus, w.projectileSize, 'white'));
                return;
            }

            if(w.type === 'ranged_spread'){
                if(!closest) return;
                const n = w.pellet;
                const spread = (w.spreadDeg*Math.PI/180);
                for(let i=0;i<n;i++){
                    const t = (n===1)?0:(i/(n-1)-0.5);
                    const a = angle + t*spread;
                    projectiles.push(makeProjectile(player.x, player.y, a, w.projectileSpeed, dmg, w.pierce + player.projectilePierceBonus, w.projectileSize, 'white'));
                }
                return;
            }

            if(w.type === 'pulse'){
                effects.push({
                    type:'pulse', x: player.x, y: player.y,
                    currentRadius: 0, maxRadius: w.maxRadius,
                    pulseSpeed: w.pulseSpeed, damage: dmg,
                    duration: (w.maxRadius/w.pulseSpeed)*16.67, maxDuration: (w.maxRadius/w.pulseSpeed)*16.67,
                    hitEnemies: [],
                });
                return;
            }

            if(w.type === 'chain'){
                if(!closest) return;
                let cur = closest;
                const hit = new Set();
                const segs = [];
                for(let i=0;i<w.bounces;i++){
                    if(!cur) break;
                    hit.add(cur.id);
                    const { dmg:finalDmg, isCrit } = calcDamage(w.baseDmg);
                    enemyTakeDamage(cur, finalDmg, isCrit);
                    const next = findNearestNotHit(cur.x, cur.y, w.bounceRange, hit);
                    if(next) segs.push({x1:cur.x,y1:cur.y,x2:next.x,y2:next.y});
                    cur = next;
                }
                if(segs.length) effects.push({ type:'chain', segs, duration:180, maxDuration:180 });
                return;
            }

            if(w.type === 'mine'){
                mines.push({
                    x: player.x, y: player.y,
                    triggerRadius: w.triggerRadius,
                    blastRadius: w.blastRadius,
                    damage: dmg,
                    timer: 0,
                    armed: false,
                    cluster: w.cluster || 0,
                });
                effects.push({ type:'mine_drop', x:player.x, y:player.y, duration:160, maxDuration:160 });
                return;
            }

            if(w.type === 'ranged_bomb'){
                if(!closest) return;
                projectiles.push(makeProjectile(player.x, player.y, angle, w.projectileSpeed, dmg, 1, w.projectileSize, 'bomb', { blastRadius:w.blastRadius }));
                return;
            }

            if(w.type === 'laser'){
                if(!closest) return;
                effects.push({
                    type:'laser', x: player.x, y: player.y, angle,
                    range: w.range, width: w.width, damage: dmg,
                    duration: w.duration, maxDuration: w.duration,
                    hitEnemies: [],
                });
                return;
            }

            if(w.type === 'field'){
                for(const enemy of enemies){
                    if(Math.hypot(enemy.x - player.x, enemy.y - player.y) < w.radius){
                        const { dmg:finalDmg, isCrit } = calcDamage(w.baseDmg);
                        enemyTakeDamage(enemy, finalDmg * 0.5, isCrit);
                    }
                }
                return;
            }

            if(w.type === 'boomerang'){
                if(!closest) return;
                projectiles.push({
                    x: player.x, y: player.y,
                    angle, speed: w.projectileSpeed,
                    damage: dmg, pierce: 999,
                    size: w.projectileSize,
                    kind: 'boomerang',
                    maxDist: w.maxDist,
                    startX: player.x, startY: player.y,
                    returning: false,
                    hitEnemies: [],
                    lived: 0,
                });
                return;
            }
        }

        function findNearestNotHit(x,y, range, hitSet){
            let best = null;
            let bestD = Infinity;
            for(const e of enemies){
                if(hitSet.has(e.id)) continue;
                const d = Math.hypot(e.x-x, e.y-y);
                if(d < range && d < bestD){ bestD = d; best = e; }
            }
            return best;
        }

        function makeProjectile(x,y,angle,speed,damage,pierce,size,kind,extra){
            return { x,y,angle,speed,damage,pierce,size, kind, extra: extra||null, hitEnemies: [], lived: 0 };
        }

        function explodeMine(m){
            for(const e of enemies){
                if(Math.hypot(e.x - m.x, e.y - m.y) < m.blastRadius){
                    const { dmg, isCrit } = calcDamage(m.damage);
                    enemyTakeDamage(e, dmg, isCrit);
                }
            }
            effects.push({ type:'explosion', x:m.x, y:m.y, radius:m.blastRadius, duration:260, maxDuration:260 });

            // cluster
            if(m.cluster && m.cluster > 0){
                for(let i=0; i<m.cluster; i++){
                    const a = (Math.PI*2/m.cluster)*i;
                    const dist = 40;
                    mines.push({
                        x: m.x + Math.cos(a)*dist,
                        y: m.y + Math.sin(a)*dist,
                        triggerRadius: m.triggerRadius * 0.7,
                        blastRadius: m.blastRadius * 0.6,
                        damage: m.damage * 0.5,
                        timer: 200,
                        armed: false,
                        cluster: 0,
                    });
                }
            }
        }

        function playerTakeDamage(damage, enemyType){
            if(player.shields > 0){
                player.shields--;
                effects.push({ type:'shield_pop', x:player.x, y:player.y, duration:220, maxDuration:220 });
                return;
            }

            if(player.invincible) return;

            let mult = 1.0;
            if(enemyType === 'bacteria') mult *= player.bacteriaDamageTakenMult;
            else mult *= player.virusDamageTakenMult;

            const actual = Math.max(1, (damage * mult) - player.defense);
            player.hp -= actual;
            player.infection = clamp(player.infection + actual * 5.0 * player.infectionGainMult, 0, 120);

            player.invincible = true;
            player.invincibleTimer = 340;

            uiContainer.classList.add('shake');
            setTimeout(() => uiContainer.classList.remove('shake'), 220);

            if(player.hp <= 0){
                player.hp = 0;
                loseGame();
            }
        }

        function enemyTakeDamage(enemy, damage, isCrit){
            enemy.hp -= damage;
            enemy.isHit = true;
            enemy.hitTimer = 90;
            if(isCrit) enemy.critHit = true;

            // lifesteal
            if(player.lifesteal > 0){
                player.hp = Math.min(player.maxHp, player.hp + damage * player.lifesteal);
            }

            if(enemy.hp <= 0){
                onEnemyKilled(enemy);
                enemies = enemies.filter(e => e.id !== enemy.id);
            }
        }

        function onEnemyKilled(e){
            runStats.kills++;
            player.kills++;

            if(player.healOnKill > 0){
                player.hp = Math.min(player.maxHp, player.hp + player.healOnKill);
            }

            createPickups(e);
        }

        // ===== Spawning =====
        function spawnEnemies(){
            const sec = (600000 - gameTimeMs) / 1000;
            const clip = SPAWNER_CLIPS.find(c => sec >= c.start && sec < c.end);
            if(!clip) return;

            const hpMult  = 1 + sec * 0.0038;
            const spdMult = 1 + sec * 0.0013;
            const dmgMult = 1 + sec * 0.0022;

            const bacteriaEnabled = sec >= 150;
            const antibioticLv = meta.upgrades.antibiotic || 0;
            const bacteriaSpawnMult = clamp(1 - antibioticLv * 0.04, 0.55, 1.0);

            for(const sInfo of clip.enemies){
                if(!lastSpawnTimes[sInfo.type]) lastSpawnTimes[sInfo.type] = 0;

                const timePressure = 1 + sec/180 * 0.35;
                const every = sInfo.every / timePressure;

                if(sec - lastSpawnTimes[sInfo.type] > every){
                    lastSpawnTimes[sInfo.type] = sec;

                    let n = Math.floor(rand() * (sInfo.count[1] - sInfo.count[0] + 1)) + sInfo.count[0];

                    for(let i=0; i<n; i++){
                        if(enemies.length > 350) break;
                        spawnOne(sInfo.type, hpMult, spdMult, dmgMult);
                    }
                }
            }

            // bacteria
            if(bacteriaEnabled){
                const key = "__bacteria";
                if(!lastSpawnTimes[key]) lastSpawnTimes[key] = 0;
                const everyB = 8.5 / (1 + sec/240);
                if(sec - lastSpawnTimes[key] > everyB){
                    lastSpawnTimes[key] = sec;
                    const n = Math.max(1, Math.floor((2 + rand()*2) * bacteriaSpawnMult));
                    for(let i=0;i<n;i++){
                        if(enemies.length > 350) break;
                        spawnOne("bacteria", hpMult, spdMult, dmgMult);
                    }
                }
            }
        }

        function spawnOne(type, hpMult, spdMult, dmgMult){
            const a = rand() * Math.PI * 2;
            const r = Math.max(canvas.width/2, canvas.height/2) + 150;
            const x = player.x + Math.cos(a) * r;
            const y = player.y + Math.sin(a) * r;
            const base = ENEMY_CATALOG[type];
            const elapsedSec = (600000 - gameTimeMs) / 1000;
            const skinTier = clamp(Math.floor(elapsedSec / 100), 0, 5);

            // âœ… í¬ê¸°(ì¢…) ë³€ì´: ìŠ¤í°ë  ë•Œ í¬ê¸°/ìŠ¤íƒ¯ì´ ì¡°ê¸ˆì”© ë‹¬ë¼ì ¸ "ì¢…ë¥˜ê°€ ë§ì•„ ë³´ì´ê²Œ" ì—°ì¶œ
            // - swarm: ì‘ê³  ë¹ ë¦„ (ì²´ë ¥â†“)
            // - brute: í¬ê³  ë‘”í•¨ (ì²´ë ¥â†‘)
            let variant = "normal";
            let sizeMult = 1.0, hpVar = 1.0, spdVar = 1.0, dmgVar = 1.0, xpVar = 1.0;
            const rVar = rand();
            if(rVar < 0.55){
                variant = "normal";
                sizeMult = 0.90 + rand()*0.25;
            } else if(rVar < 0.82){
                variant = "swarm";
                sizeMult = 0.62 + rand()*0.18;
                hpVar = 0.75; spdVar = 1.18; dmgVar = 0.85; xpVar = 0.85;
            } else {
                variant = "brute";
                sizeMult = 1.22 + rand()*0.38;
                hpVar = 1.35; spdVar = 0.86; dmgVar = 1.15; xpVar = 1.40;
            }
            sizeMult = clamp(sizeMult, 0.65, 1.55);

            const eSize = base.size * sizeMult;
            const eMaxHp = base.hp * hpMult * hpVar;
            const eSpeed = base.spd * spdMult * spdVar;
            const eDmg = base.dmg * dmgMult * dmgVar;
            const eXp = Math.max(1, Math.round((base.xp || 1) * xpVar));

            enemies.push({
                ...base,
                type,
                x, y,
                skinTier,
                variant,
                size: eSize,
                hp: eMaxHp,
                maxHp: eMaxHp,
                speed: eSpeed,
                dmg: eDmg,
                xp: eXp,
                id: (Math.floor(rand()*1e9) ^ Date.now()) >>> 0,
                isHit:false,
                hitTimer:0,
                shootTimer: 800 + rand()*800,
                chargeTimer: 1000 + rand()*1000,
                charging: false,
                chargeDir: 0,
                chargeTime: 0,
            });
        }

        function spawnSuperVirus(){
            const base = ENEMY_CATALOG.superVirus;
            const a = rand() * Math.PI * 2;
            const r = Math.max(canvas.width/2, canvas.height/2) + 150;
            enemies.push({
                ...base,
                type: "superVirus",
                x: player.x + Math.cos(a) * r,
                y: player.y + Math.sin(a) * r,
                hp: base.hp,
                maxHp: base.hp,
                speed: base.spd,
                dmg: base.dmg,
                id: (Math.floor(rand()*1e9) ^ Date.now()) >>> 0,
                isHit:false,
                hitTimer:0,
            });
            showToast("âš ï¸ ìŠˆí¼ë°”ì´ëŸ¬ìŠ¤ ì¶œí˜„!");
        }

        function updateEnemy(e, dt){
            if(e.hitTimer > 0) e.hitTimer -= dt;
            else { e.isHit = false; e.critHit = false; }

            // special behaviors
            if(e.type === 'spitterVirus'){
                e.shootTimer -= dt;
                if(e.shootTimer <= 0){
                    e.shootTimer = 1800 + rand()*1200;
                    const angle = Math.atan2(player.y - e.y, player.x - e.x);
                    enemyProjectiles.push({
                        x: e.x, y: e.y, angle,
                        speed: 4.5, damage: e.dmg * 0.6,
                        size: 8, maxLife: 2000, lived: 0,
                    });
                }
            }

            if(e.type === 'chargerVirus'){
                if(!e.charging){
                    e.chargeTimer -= dt;
                    if(e.chargeTimer <= 0 && Math.hypot(player.x - e.x, player.y - e.y) < 300){
                        e.charging = true;
                        e.chargeDir = Math.atan2(player.y - e.y, player.x - e.x);
                        e.chargeTime = 400;
                    }
                }
                if(e.charging){
                    e.chargeTime -= dt;
                    e.x += Math.cos(e.chargeDir) * e.speed * 3 * (dt/16.67);
                    e.y += Math.sin(e.chargeDir) * e.speed * 3 * (dt/16.67);
                    if(e.chargeTime <= 0){
                        e.charging = false;
                        e.chargeTimer = 2000 + rand()*1500;
                    }
                    return;
                }
            }

            // normal movement
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy);
            if(dist > 5){
                e.x += (dx/dist) * e.speed * (dt/16.67);
                e.y += (dy/dist) * e.speed * (dt/16.67);
            }
        }

        function updateProjectile(p, dt){
            p.lived += dt;

            if(p.kind === 'boomerang'){
                const distFromStart = Math.hypot(p.x - p.startX, p.y - p.startY);
                if(!p.returning && distFromStart >= p.maxDist){
                    p.returning = true;
                }
                if(p.returning){
                    const toPlayer = Math.atan2(player.y - p.y, player.x - p.x);
                    p.angle = toPlayer;
                    if(Math.hypot(player.x - p.x, player.y - p.y) < player.size){
                        p.dead = true;
                    }
                }
            }

            p.x += Math.cos(p.angle) * p.speed * (dt/16.67);
            p.y += Math.sin(p.angle) * p.speed * (dt/16.67);
        }

        function updatePickup(p){
            const dx = player.x - p.x;
            const dy = player.y - p.y;
            const dist = Math.hypot(dx, dy);

            if(dist < player.pickupRadius * 1.5){
                const speed = 8;
                p.x += (dx/dist) * speed;
                p.y += (dy/dist) * speed;
            }

            if(dist < player.size/2 + 10){
                if(p.type === 'xp'){
                    player.xp += p.value * player.xpMultiplier;
                    checkLevelUp();
                } else if(p.type === 'atp'){
                    player.atp += p.value;
                } else if(p.type === 'heal'){
                    player.hp = Math.min(player.maxHp, player.hp + p.value);
                }
                pickups = pickups.filter(x => x !== p);
            }
        }

        function createPickups(enemy){
            const xpVal = enemy.xp || 1;
            pickups.push({ type:'xp', x: enemy.x, y: enemy.y, value: xpVal });

            if(rand() < 0.15){
                pickups.push({ type:'atp', x: enemy.x + 10, y: enemy.y, value: 1 });
            }
            if(rand() < 0.03){
                pickups.push({ type:'heal', x: enemy.x - 10, y: enemy.y, value: 5 });
            }
        }

        function checkLevelUp(){
            while(player.xp >= player.xpToNextLevel){
                player.xp -= player.xpToNextLevel;
                player.level++;
                player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.18);
                showLevelUpOptions();
            }
        }

        function showLevelUpOptions(){
            gameState = 'paused';
            setCanvasInputEnabled(false);
            levelUpModal.style.display = 'flex';
            cardOptionsContainer.innerHTML = '';

            const options = generateLevelUpOptions();

            options.forEach(opt => {
                const card = document.createElement('div');
                card.className = 'card ui-element w-48 p-4 cursor-pointer text-center';
                card.innerHTML = `
                <div class="text-lg font-black text-slate-900 mb-2">${opt.name}</div>
                <div class="text-sm text-slate-600 mb-2">${opt.desc}</div>
                <div class="text-xs text-emerald-600 font-bold">${opt.levelText || ''}</div>
            `;
                card.onclick = () => {
                    if(opt.isWeapon){
                        if(player.weapons[opt.id]){
                            player.weapons[opt.id].level = (player.weapons[opt.id].level || 1) + 1;
                            upgradeWeapon(player.weapons[opt.id]);
                        } else {
                            addWeapon(opt.id, true, false);
                        }
                    } else {
                        if(player.passives[opt.id]){
                            player.passives[opt.id].level = (player.passives[opt.id].level || 1) + 1;
                        } else {
                            addPassive(opt.id);
                        }
                    }
                    tryEvolveWeapons();
                    levelUpModal.style.display = 'none';
                    gameState = 'playing';
                    setCanvasInputEnabled(true);
                };
                cardOptionsContainer.appendChild(card);
            });
        }

        function generateLevelUpOptions(){
            const weapons = [];
            const passives = [];
            const numOptions = 4 + (player.luckyBonus || 0);

            // weapons (ê³µê²© ìŠ¤í‚¬)
            for(const [id, w] of Object.entries(WEAPON_DB)){
                if(w.hidden) continue;
                if(!meta.unlockedWeapons[id]) continue;
                const owned = player.weapons[id];
                const level = owned ? (owned.level || 1) : 0;
                if(level >= 8) continue;
                weapons.push({
                    id, name: w.name, desc: w.desc, isWeapon: true,
                    levelText: owned ? `Lv.${level} â†’ ${level+1}` : 'ì‹ ê·œ',
                    priority: owned ? 2 : 1,
                });
            }

            // passives
            for(const [id, p] of Object.entries(PASSIVE_DB)){
                const owned = player.passives[id];
                const level = owned ? (owned.level || 1) : 0;
                if(level >= 5) continue;
                passives.push({
                    id, name: p.name, desc: p.desc, isWeapon: false,
                    levelText: owned ? `Lv.${level} â†’ ${level+1}` : 'ì‹ ê·œ',
                    priority: owned ? 2 : 1,
                });
            }

            // shuffle helper
            const shuffle = (arr) => {
                for(let i = arr.length - 1; i > 0; i--){
                    const j = Math.floor(rand() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            };

            shuffle(weapons);
            shuffle(passives);

            // âœ… ê³µê²© ìŠ¤í‚¬ì´ ë¶€ì¡±í•´ ë³´ì´ëŠ” ë¬¸ì œ ë³´ì™„: ê°€ëŠ¥í•œ í•œ ë¬´ê¸°(ê³µê²©) ì˜µì…˜ì„ ë” ì„ëŠ”ë‹¤
            let wantWeapons = Math.min(2, weapons.length, numOptions);
            if(passives.length > 0) wantWeapons = Math.min(wantWeapons, numOptions - 1); // íŒ¨ì‹œë¸Œ 1ì¹¸ì€ ë‚¨ê¸°ê¸°(ê°€ëŠ¥í•œ ê²½ìš°)

            const picked = [];
            picked.push(...weapons.slice(0, wantWeapons));
            picked.push(...passives.slice(0, numOptions - wantWeapons));

            // ë¶€ì¡±í•˜ë©´ ë‚¨ì€ ê²ƒì—ì„œ ì±„ì›€
            const remain = [
                ...weapons.slice(wantWeapons),
                ...passives.slice(numOptions - wantWeapons),
            ];
            shuffle(remain);
            while(picked.length < numOptions && remain.length > 0){
                picked.push(remain.pop());
            }

            shuffle(picked);
            return picked.slice(0, numOptions);
        }

        function addWeapon(id, applyImmediately = true, isStart = false){
            const template = WEAPON_DB[id];
            if(!template) return;

            const w = { ...template, id, level: 1, timer: isStart ? 500 : 0 };

            if(w.type === 'orbital'){
                w.orbitals = [];
                for(let i=0; i<(w.count||1); i++){
                    w.orbitals.push({ angle: (Math.PI*2/w.count)*i });
                }
            }

            player.weapons[id] = w;
        }

        function upgradeWeapon(w){
            const mult = 1.12;
            w.baseDmg *= mult;
            if(w.cooldown > 100) w.cooldown *= 0.95;
            if(w.pierce) w.pierce += 1;
            if(w.count && w.type === 'orbital'){
                w.count++;
                w.orbitals.push({ angle: rand() * Math.PI * 2 });
            }
            if(w.pellet) w.pellet++;
            if(w.bounces) w.bounces++;
            if(w.range) w.range *= 1.08;
            if(w.maxRadius) w.maxRadius *= 1.1;
            if(w.blastRadius) w.blastRadius *= 1.08;
            if(w.radius) w.radius *= 1.1;
        }

        function addPassive(id){
            const template = PASSIVE_DB[id];
            if(!template) return;

            player.passives[id] = { ...template, id, level: 1 };
            template.effect(player);
        }

        // ===== Collisions =====
        function checkCollisions(){
            // player vs enemies
            for(const e of enemies){
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if(dist < player.size/2 + e.size/2){
                    playerTakeDamage(e.dmg, e.type);

                    // thorns
                    if(player.thorns > 0){
                        enemyTakeDamage(e, player.thorns, false);
                    }
                }
            }

            // projectiles vs enemies
            for(const p of projectiles){
                for(const e of enemies){
                    if(p.hitEnemies.includes(e.id)) continue;
                    const dist = Math.hypot(p.x - e.x, p.y - e.y);
                    if(dist < p.size/2 + e.size/2){
                        const { dmg, isCrit } = calcDamage(p.damage);
                        enemyTakeDamage(e, dmg, isCrit);
                        p.hitEnemies.push(e.id);
                        p.pierce--;

                        // bomb explosion
                        if(p.kind === 'bomb' && p.extra?.blastRadius){
                            for(const e2 of enemies){
                                if(Math.hypot(e2.x - p.x, e2.y - p.y) < p.extra.blastRadius){
                                    if(!p.hitEnemies.includes(e2.id)){
                                        const { dmg:d2, isCrit:c2 } = calcDamage(p.damage * 0.7);
                                        enemyTakeDamage(e2, d2, c2);
                                        p.hitEnemies.push(e2.id);
                                    }
                                }
                            }
                            effects.push({ type:'explosion', x:p.x, y:p.y, radius:p.extra.blastRadius, duration:220, maxDuration:220 });
                            p.pierce = 0;
                        }

                        if(p.pierce <= 0){ p.dead = true; break; }
                    }
                }
            }

            // orbitals vs enemies
            for(const w of Object.values(player.weapons)){
                if(w.type !== 'orbital') continue;
                for(const o of w.orbitals){
                    const ox = player.x + Math.cos(o.angle) * w.orbitRadius;
                    const oy = player.y + Math.sin(o.angle) * w.orbitRadius;
                    for(const e of enemies){
                        const dist = Math.hypot(ox - e.x, oy - e.y);
                        if(dist < 20 + e.size/2){
                            const now = Date.now();
                            if(!o.lastHit) o.lastHit = {};
                            if(!o.lastHit[e.id] || now - o.lastHit[e.id] > 300){
                                o.lastHit[e.id] = now;
                                const { dmg, isCrit } = calcDamage(w.baseDmg);
                                enemyTakeDamage(e, dmg, isCrit);
                            }
                        }
                    }
                }
            }

            // pulses
            for(const ef of effects){
                if(ef.type === 'pulse'){
                    for(const e of enemies){
                        if(ef.hitEnemies.includes(e.id)) continue;
                        const dist = Math.hypot(ef.x - e.x, ef.y - e.y);
                        if(dist < ef.currentRadius && dist > ef.currentRadius - 30){
                            ef.hitEnemies.push(e.id);
                            const { dmg, isCrit } = calcDamage(ef.damage);
                            enemyTakeDamage(e, dmg, isCrit);
                        }
                    }
                }

                // laser
                if(ef.type === 'laser'){
                    for(const e of enemies){
                        if(ef.hitEnemies.includes(e.id)) continue;
                        // line-circle collision
                        const dx = Math.cos(ef.angle);
                        const dy = Math.sin(ef.angle);
                        const fx = e.x - ef.x;
                        const fy = e.y - ef.y;
                        const t = clamp(fx*dx + fy*dy, 0, ef.range);
                        const closestX = ef.x + dx * t;
                        const closestY = ef.y + dy * t;
                        const dist = Math.hypot(e.x - closestX, e.y - closestY);
                        if(dist < ef.width/2 + e.size/2){
                            ef.hitEnemies.push(e.id);
                            const { dmg, isCrit } = calcDamage(ef.damage);
                            enemyTakeDamage(e, dmg, isCrit);
                        }
                    }
                }
            }

            // enemy projectiles vs player
            for(let i=enemyProjectiles.length-1; i>=0; i--){
                const p = enemyProjectiles[i];
                const dist = Math.hypot(p.x - player.x, p.y - player.y);
                if(dist < p.size + player.size/2){
                    playerTakeDamage(p.damage, 'virus');
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        // ===== UI =====
        function updateUI(){
            const hpPct = clamp(player.hp / player.maxHp * 100, 0, 100);
            hpBar.style.width = `${hpPct}%`;
            hpText.textContent = `${Math.ceil(player.hp)} / ${Math.ceil(player.maxHp)}`;

            const infPct = clamp(player.infection / 120 * 100, 0, 100);
            infectionBar.style.width = `${infPct}%`;
            infectionText.textContent = `${Math.floor(player.infection)}%`;

            const xpPct = clamp(player.xp / player.xpToNextLevel * 100, 0, 100);
            xpBar.style.width = `${xpPct}%`;
            xpText.textContent = `${Math.floor(player.xp)} / ${player.xpToNextLevel}`;

            levelDisplay.textContent = `ë ˆë²¨: ${player.level}`;
            killsText.textContent = `${player.kills}`;
            shieldText.textContent = `ğŸ›¡ï¸ ${player.shields}`;

            const mins = Math.floor(gameTimeMs / 60000);
            const secs = Math.floor((gameTimeMs % 60000) / 1000);
            timerDisplay.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

            atpText.textContent = `${player.atp}`;
            goldHudText.textContent = `${meta.gold}`;

            // weapon UI
            let whtml = '<div class="font-bold mb-1">ë¬´ê¸°</div>';
            for(const [id, w] of Object.entries(player.weapons)){
                whtml += `<div>${w.name} Lv.${w.level||1}</div>`;
            }
            weaponUI.innerHTML = whtml;

            // passive UI
            let phtml = '<div class="font-bold mb-1">íŒ¨ì‹œë¸Œ</div>';
            for(const [id, p] of Object.entries(player.passives)){
                phtml += `<div>${p.name} Lv.${p.level||1}</div>`;
            }
            passiveUI.innerHTML = phtml;
        }

        // ===== Drawing =====
        function draw(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            const gridSize = 100;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for(let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize){
                ctx.beginPath();
                ctx.moveTo(x, camera.y);
                ctx.lineTo(x, camera.y + canvas.height);
                ctx.stroke();
            }
            for(let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize){
                ctx.beginPath();
                ctx.moveTo(camera.x, y);
                ctx.lineTo(camera.x + canvas.width, y);
                ctx.stroke();
            }

            // pickups
            for(const p of pickups){
                if(p.type === 'xp'){
                    ctx.fillStyle = '#a78bfa';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
                    ctx.fill();
                } else if(p.type === 'atp'){
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                    ctx.fill();
                } else if(p.type === 'heal'){
                    ctx.fillStyle = '#34d399';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // mines
            for(const m of mines){
                ctx.fillStyle = m.armed ? 'rgba(255,100,100,0.7)' : 'rgba(200,200,200,0.5)';
                ctx.beginPath();
                ctx.arc(m.x, m.y, 12, 0, Math.PI*2);
                ctx.fill();
                if(m.armed){
                    ctx.strokeStyle = 'rgba(255,100,100,0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.triggerRadius, 0, Math.PI*2);
                    ctx.stroke();
                }
            }

            // enemies
            const vImg = imageCache['virus'];
            for(const e of enemies){
                ctx.save();
                if(e.isHit){
                    ctx.globalAlpha = 0.6;
                    if(e.critHit) ctx.filter = 'brightness(2)';
                }
                if(e.type === 'superVirus'){
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2);
                    ctx.fill();
                    // hp bar
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(e.x - 20, e.y - e.size/2 - 10, 40, 6);
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(e.x - 20, e.y - e.size/2 - 10, 40 * (e.hp/e.maxHp), 6);
                } else if(e.type === 'bacteria'){
                    ctx.fillStyle = '#84cc16';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2);
                    ctx.fill();
                } else if(vImg && vImg.complete){
                    ctx.drawImage(vImg, e.x - e.size/2, e.y - e.size/2, e.size, e.size);
                } else {
                    ctx.fillStyle = e.type === 'chargerVirus' ? '#f97316' : (e.type === 'spitterVirus' ? '#22d3ee' : '#22c55e');
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // projectiles
            for(const p of projectiles){
                ctx.fillStyle = p.kind === 'bomb' ? '#f97316' : (p.kind === 'boomerang' ? '#06b6d4' : '#fff');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                ctx.fill();
            }

            // enemy projectiles
            for(const p of enemyProjectiles){
                ctx.fillStyle = '#84cc16';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                ctx.fill();
            }

            // orbitals
            for(const w of Object.values(player.weapons || {})){
                if(w.type !== 'orbital') continue;
                for(const o of w.orbitals){
                    const ox = player.x + Math.cos(o.angle) * w.orbitRadius;
                    const oy = player.y + Math.sin(o.angle) * w.orbitRadius;
                    ctx.fillStyle = 'rgba(96,165,250,0.8)';
                    ctx.beginPath();
                    ctx.arc(ox, oy, 14, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // field
            for(const w of Object.values(player.weapons || {})){
                if(w.type !== 'field') continue;
                ctx.fillStyle = 'rgba(168,85,247,0.15)';
                ctx.beginPath();
                ctx.arc(player.x, player.y, w.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(168,85,247,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // player
            const pSkin = player ? (CHAR_SKIN_MAP[selectedCharId] ?? 0) : 0;
            const pImg = imageCache.cell?.[pSkin];
            if(player){
                if(player.invincible){
                    ctx.globalAlpha = (Math.floor(player.invincibleTimer/100) % 2 === 0) ? 0.5 : 1.0;
                }
                if(pImg && pImg.complete){
                    ctx.drawImage(pImg, player.x - player.size/2, player.y - player.size/2, player.size, player.size);
                } else {
                    const char = CHARACTER_DB[selectedCharId];
                    ctx.fillStyle = char?.color || '#f472b6';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size/2, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;

                // shields visual
                if(player.shields > 0){
                    ctx.strokeStyle = 'rgba(56,189,248,0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size/2 + 8, 0, Math.PI*2);
                    ctx.stroke();
                }
            }

            // effects
            for(const e of effects){
                const op = clamp(e.duration / e.maxDuration, 0, 1);

                if(e.type === 'slash_arc'){
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle);
                    ctx.strokeStyle = `rgba(255,255,255,${op*0.7})`;
                    ctx.lineWidth = 16;
                    ctx.beginPath();
                    ctx.arc(0, 0, e.range, -e.angleWidth/2, e.angleWidth/2);
                    ctx.stroke();
                    ctx.restore();
                }

                if(e.type === 'slam_circle'){
                    ctx.fillStyle = `rgba(255,120,160,${op*0.5})`;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius*(1-op*0.3), 0, Math.PI*2);
                    ctx.fill();
                }

                if(e.type === 'pulse'){
                    ctx.strokeStyle = `rgba(120,220,255,${op*0.5})`;
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.currentRadius, 0, Math.PI*2);
                    ctx.stroke();
                }

                if(e.type === 'chain'){
                    ctx.strokeStyle = `rgba(250,204,21,${op*0.8})`;
                    ctx.lineWidth = 4;
                    for(const seg of e.segs){
                        ctx.beginPath();
                        ctx.moveTo(seg.x1, seg.y1);
                        ctx.lineTo(seg.x2, seg.y2);
                        ctx.stroke();
                    }
                }

                if(e.type === 'explosion'){
                    ctx.fillStyle = `rgba(251,146,60,${op*0.6})`;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius*(1-op*0.4), 0, Math.PI*2);
                    ctx.fill();
                }

                if(e.type === 'laser'){
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle);
                    ctx.fillStyle = `rgba(239,68,68,${op*0.7})`;
                    ctx.fillRect(0, -e.width/2, e.range, e.width);
                    ctx.restore();
                }

                if(e.type === 'shield_pop'){
                    ctx.strokeStyle = `rgba(56,189,248,${op*0.7})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 30 + (1-op)*20, 0, Math.PI*2);
                    ctx.stroke();
                }
            }

            ctx.restore();

            if(gameState === 'title'){
                ctx.fillStyle = "rgba(0,0,0,0.15)";
                ctx.fillRect(0,0,canvas.width,canvas.height);
            }
        }

        // ===== End states =====
        function endRunAndGrantGold(score){
            const survivedSec = Math.floor((600000 - gameTimeMs)/1000);
            const goldEarned = Math.max(0, Math.floor(
                (player.atp * 1.2) + (survivedSec / 12) + (player.level * 2.2) + (player.kills * 0.18)
            ));

            meta.gold += goldEarned;
            runStats.goldEarned = goldEarned;
            runGoldText.textContent = `${goldEarned}`;
            goldHudText.textContent = `${meta.gold}`;

            if(score > (meta.bestScore||0)){
                meta.bestScore = score;
            }
            saveMeta();
        }

        function loseGame(){
            if(gameState === 'gameOver') return;
            gameState = 'gameOver';

            const survivedSec = Math.floor((600000 - gameTimeMs)/1000);
            const score = Math.floor(player.level*150 + player.atp*40 + survivedSec*1.5 + player.kills*5);

            endRunAndGrantGold(score);

            gameOverTitle.textContent = "ì„¸í¬ê°€ ë¶•ê´´í–ˆìŠµë‹ˆë‹¤";
            gameOverText.textContent = `ìƒì¡´: ${survivedSec}ì´ˆ â€¢ ë ˆë²¨: ${player.level} â€¢ ì²˜ì¹˜: ${player.kills} â€¢ ATP: ${player.atp} â€¢ ì ìˆ˜: ${score}`;
            gameOverModal.style.display = 'flex';
            setCanvasInputEnabled(false);
        }

        function winGame(message){
            if(gameState === 'gameOver') return;
            gameState = 'gameOver';

            const survivedSec = 600;
            const score = Math.floor(player.level*250 + player.atp*60 + Math.floor(player.hp*10) + player.kills*6);

            endRunAndGrantGold(score);

            gameOverTitle.textContent = message;
            gameOverText.textContent = `ì™„ì£¼! ë ˆë²¨: ${player.level} â€¢ HP: ${Math.ceil(player.hp)} â€¢ ì²˜ì¹˜: ${player.kills} â€¢ ATP: ${player.atp} â€¢ ì ìˆ˜: ${score}`;
            gameOverModal.style.display = 'flex';
            setCanvasInputEnabled(false);
        }

        // ===== Game loop =====
        function gameLoop(ts){
            if(gameState !== 'playing' && gameState !== 'paused'){
                draw();
                return;
            }
            if(!lastTime) lastTime = ts;
            const dt = Math.min(ts - lastTime, 50);
            lastTime = ts;

            if(gameState === 'playing'){
                update(dt);
                updateUI();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ===== Modals =====
        function openLab(){
            labReturnState = gameState;
            setCanvasInputEnabled(false);

            // ëª¨ë‹¬ ê²¹ì¹¨ ë°©ì§€: (íŠ¹íˆ íƒ€ì´í‹€ì´ z-indexë¡œ ì—°êµ¬ì†Œ ìœ„ë¥¼ ë®ëŠ” ì¼€ì´ìŠ¤)
            gameOverModal.style.display = "none";
            levelUpModal.style.display = "none";
            charModal.style.display = "none";
            titleModal.style.display = "none";
            titleModal.classList.add("hidden");

            renderLab();
            labModal.classList.remove("hidden");
            labModal.style.display = "flex";

            if(gameState === "playing") gameState = "paused";
        }
        function closeLab(){
            labModal.style.display = "none";
            labModal.classList.add("hidden");

            if(labReturnState === "playing"){
                gameState = "playing";
                setCanvasInputEnabled(true);
                return;
            }
            if(labReturnState === "paused"){
                gameState = "paused";
                setCanvasInputEnabled(true);
                return;
            }
            if(labReturnState === "gameOver"){
                gameState = "gameOver";
                gameOverModal.style.display = "flex";
                return;
            }

            // default: title
            gameState = "title";
            titleModal.classList.remove("hidden");
            titleModal.style.display = "flex";
        }

        // ===== Events =====
        startBtn.addEventListener('click', () => openCharSelect());
        openLabBtn.addEventListener('click', () => openLab());
        openLabInGameBtn.addEventListener('click', () => openLab());
        openLabFromGameOverBtn.addEventListener('click', () => openLab());
        closeLabBtn.addEventListener('click', () => closeLab());
        closeCharBtn.addEventListener('click', () => {
            charModal.style.display = "none";
            setCanvasInputEnabled(false);
            // ìºë¦­í„° ì„ íƒì„ ì·¨ì†Œí–ˆì„ ë•Œ ì›ë˜ í™”ë©´ìœ¼ë¡œ ë³µê·€
            if(charSelectReturnState === 'gameOver'){
                gameOverModal.style.display = 'flex';
            } else {
                titleModal.classList.remove('hidden');
                titleModal.style.display = 'flex';
                gameState = 'title';
            }
        });
        restartBtn.addEventListener('click', () => openCharSelect());
        backToTitleBtn.addEventListener('click', backToTitle);

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if(e.key === ' '){
                if(gameState === 'playing') gameState = 'paused';
                else if(gameState === 'paused') gameState = 'playing';
            }
            if(e.key === 'Escape'){
                if(labModal.style.display === "flex") closeLab();
                if(charModal.style.display === "flex") charModal.style.display = "none";
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // Touch
        canvas.addEventListener('pointerdown', (e) => {
            if(gameState !== 'playing') return;
            touch.active = true;
            touch.id = e.pointerId;
            touch.startX = e.clientX;
            touch.startY = e.clientY;
            touch.dx = 0;
            touch.dy = 0;
            canvas.setPointerCapture(e.pointerId);
        });
        canvas.addEventListener('pointermove', (e) => {
            if(!touch.active || touch.id !== e.pointerId) return;
            const dx = e.clientX - touch.startX;
            const dy = e.clientY - touch.startY;
            const k = 0.012;
            touch.dx = clamp(dx * k, -1, 1);
            touch.dy = clamp(dy * k, -1, 1);
        });
        function endTouch(e){
            if(!touch.active || touch.id !== e.pointerId) return;
            touch.active = false;
            touch.id = null;
            touch.dx = 0;
            touch.dy = 0;
        }
        canvas.addEventListener('pointerup', endTouch);
        canvas.addEventListener('pointercancel', endTouch);
        canvas.addEventListener('pointerout', endTouch);

        window.addEventListener('resize', resizeGame);

        // ===== Boot =====
        preloadImages();
        resizeGame();
        setCanvasInputEnabled(false);
        syncTitleMetaUI();
        renderLab();
        initGame();
        draw();
    })();
</script>
</body>
</html>
